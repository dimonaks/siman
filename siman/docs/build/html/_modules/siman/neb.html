
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>siman.neb &#8212; Siman 0.9.5 documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Siman 0.9.5 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for siman.neb</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">copy</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">itemgetter</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">from</span> <span class="nn">tabulate</span> <span class="k">import</span> <span class="n">tabulate</span>

<span class="kn">from</span> <span class="nn">siman</span> <span class="k">import</span> <span class="n">header</span>
<span class="kn">from</span> <span class="nn">siman.header</span> <span class="k">import</span> <span class="n">print_and_log</span><span class="p">,</span> <span class="n">printlog</span><span class="p">,</span> <span class="n">runBash</span>
<span class="kn">from</span> <span class="nn">siman.calc_manage</span> <span class="k">import</span> <span class="n">add_loop</span><span class="p">,</span> <span class="n">res_loop</span><span class="p">,</span> <span class="n">add_des</span><span class="p">,</span> <span class="n">inherit_ngkpt</span>
<span class="kn">from</span> <span class="nn">siman.functions</span> <span class="k">import</span>  <span class="n">return_atoms_to_cell</span><span class="p">,</span> <span class="n">push_to_server</span><span class="p">,</span> <span class="n">invert</span>
<span class="kn">from</span> <span class="nn">siman.inout</span> <span class="k">import</span> <span class="n">write_xyz</span>
<span class="kn">from</span> <span class="nn">siman.small_functions</span> <span class="k">import</span> <span class="n">is_list_like</span><span class="p">,</span> <span class="n">makedir</span>
<span class="kn">from</span> <span class="nn">siman.classes</span> <span class="k">import</span> <span class="n">CalculationVasp</span><span class="p">,</span> <span class="n">cd</span>
<span class="kn">from</span> <span class="nn">siman.geo</span> <span class="k">import</span> <span class="n">xcart2xred</span><span class="p">,</span> <span class="n">xred2xcart</span><span class="p">,</span> <span class="n">local_surrounding</span><span class="p">,</span> <span class="n">replic</span><span class="p">,</span> <span class="n">determine_symmetry_positions</span>
<span class="kn">from</span> <span class="nn">siman.impurity</span> <span class="k">import</span> <span class="n">find_pores</span><span class="p">,</span> <span class="n">determine_voids</span><span class="p">,</span> <span class="n">determine_unique_voids</span>










<div class="viewcode-block" id="determine_unique_final"><a class="viewcode-back" href="../../siman.html#siman.neb.determine_unique_final">[docs]</a><span class="k">def</span> <span class="nf">determine_unique_final</span><span class="p">(</span><span class="n">st_pores</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">avds</span><span class="p">,</span> <span class="n">x_m</span><span class="p">):</span>

    <span class="n">final_table</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">insert_positions</span> <span class="o">=</span> <span class="p">[]</span>


    <span class="sd">&quot;&quot;&quot;Please determine unique positions with similar distances taking into acc PBC!!!</span>
<span class="sd">    below is incorrect</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># crude_prec = 1</span>
    <span class="c1"># sums_crude = np.unique(sums.round(crude_prec))</span>
    <span class="c1"># print_and_log(&#39;The unique voids based on the sums:&#39;, </span>
    <span class="c1">#     &#39;\nwith 0.01 A prec:&#39;,np.unique(sums.round(2)),</span>
    <span class="c1">#     &#39;\nwith 0.1  A prec:&#39;,sums_crude,</span>
    <span class="c1">#     imp =&#39;y&#39;)</span>
    <span class="c1"># print_and_log(&#39;Based on crude criteria only&#39;, len(sums_crude),&#39;types of void are relevant&#39;, imp = &#39;y&#39;) </span>

    <span class="c1"># xcart_unique = []</span>
    <span class="c1"># avds_unique  = []</span>
    <span class="c1"># sums_unique  = []</span>

    <span class="c1"># for i, s in enumerate(sums_crude):</span>
    <span class="c1">#     index_of_first =  np.where(sums.round(crude_prec)==s)[0][0]</span>
    <span class="c1">#     xcart_unique.append(st_pores.xcart[index_of_first])</span>
    <span class="c1">#     avds_unique.append(avds[index_of_first] )</span>
    <span class="c1">#     sums_unique.append(sums[index_of_first] )</span>

    <span class="c1"># st_pores_unique = copy.deepcopy(st_pores)</span>

    <span class="c1"># st_pores_unique.xcart = xcart_unique</span>
    <span class="c1"># st_pores_unique.xcart2xred()</span>

    <span class="n">sur</span> <span class="o">=</span> <span class="n">local_surrounding</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="n">st_pores</span><span class="p">,</span> <span class="n">n_neighbours</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">st_pores</span><span class="o">.</span><span class="n">xcart</span><span class="p">),</span> <span class="n">control</span> <span class="o">=</span> <span class="s1">&#39;atoms&#39;</span><span class="p">,</span> <span class="n">periodic</span>  <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

    <span class="c1"># print(&#39;neb.determine_unique_final(): sur&#39;,  sur)</span>

    <span class="n">print_and_log</span><span class="p">(</span>
    <span class="s1">&#39;I can suggest you &#39;</span><span class="o">+</span><span class="nb">str</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sur</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">)</span><span class="o">+</span><span class="s1">&#39; end positions.&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span> <span class="p">)</span>
    

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sur</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sur</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">sur</span><span class="p">[</span><span class="mi">2</span><span class="p">])):</span>
        <span class="c1"># if i == 0:</span>
        <span class="c1">#     continue</span>
        <span class="n">final_table</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">avds</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">sums</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="p">]</span>  <span class="p">)</span>

    <span class="n">print_and_log</span><span class="p">(</span> <span class="n">tabulate</span><span class="p">(</span><span class="n">final_table</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;void #&#39;</span><span class="p">,</span> <span class="s1">&#39;Cart.&#39;</span><span class="p">,</span> <span class="s1">&#39;Dist&#39;</span><span class="p">,</span> <span class="s1">&#39;Dev.&#39;</span><span class="p">,</span> <span class="s1">&#39;Sum&#39;</span><span class="p">],</span> <span class="n">tablefmt</span><span class="o">=</span><span class="s1">&#39;psql&#39;</span><span class="p">),</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;Y&#39;</span> <span class="p">)</span>

    <span class="k">return</span> <span class="n">sur</span></div>






<div class="viewcode-block" id="add_neb"><a class="viewcode-back" href="../../siman.html#siman.neb.add_neb">[docs]</a><span class="k">def</span> <span class="nf">add_neb</span><span class="p">(</span><span class="n">starting_calc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">st</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">st_end</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">it_new</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ise_new</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">i_atom_to_move</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
    <span class="n">up</span> <span class="o">=</span> <span class="s1">&#39;up2&#39;</span><span class="p">,</span>
    <span class="n">search_type</span> <span class="o">=</span> <span class="s1">&#39;vacancy_creation&#39;</span><span class="p">,</span>
    <span class="n">images</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">r_impurity</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">corenum</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
    <span class="n">calc_method</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;neb&#39;</span><span class="p">],</span> 
    <span class="n">inherit_option</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mag_config</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">i_void_start</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">i_void_final</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
    <span class="n">atom_to_insert</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">atom_to_move</span>   <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">rep_moving_atom</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">end_pos_types_z</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">replicate</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">it_new_folder</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">it_folder</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">inherit_magmom</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">x_start</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">xr_start</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">x_final</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">xr_final</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">upload_vts</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">center_on_moving</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">run</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">add_loop_dic</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">old_behaviour</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="kc">None</span>
     <span class="p">):</span>


    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prepare needed files for NEB</span>
<span class="sd">    Provides several regimes controlled by *search_type* flag:</span>
<span class="sd">        - existing_voids - search for voids around atom and use them as a final position </span>
<span class="sd">        - vacancy_creation - search for neighbors of the same type and make a vacancy as a start position</span>
<span class="sd">        - interstitial_insertion - search for two neighboring voids; use them as start and final positions</span>
<span class="sd">                                    by inserting atom *atom_to_insert*</span>
<span class="sd">        - None - just use st and st2 as initial and final</span>

<span class="sd">    ###INPUT:</span>
<span class="sd">        - starting_calc (Calculation) - Calculation object with structure</span>
<span class="sd">        - st (Structure) - structure, can be used instead of Calculation</span>
<span class="sd">            - it_new (str) - name for calculation</span>
<span class="sd">        - st_end (Structure) - final structure</span>

<span class="sd">        - i_atom_to_move (int) - number of atom for moving starting from 0;</span>
<span class="sd">        - *mag_config* (int ) - choose magnetic configuration - allows to obtain different localizations of electron</span>
<span class="sd">        - *replicate* (tuple 3*int) - replicate cell along rprimd</span>
<span class="sd">        - i_void_start,  i_void_final (int) - position numbers of voids (or atoms) from the suggested lists</span>
<span class="sd">        - atom_to_insert  (str) - element name of atom to insert</span>
<span class="sd">        - atom_to_move (str) - element name of atom to move</span>
<span class="sd">        - it_new_folder or it_folder  (str) - section folder</span>
<span class="sd">        - inherit_option (str) - passed only to add_loop</span>
<span class="sd">        - inherit_magmom (bool) - if True than magmom from starting_calc is used, else from set</span>

<span class="sd">        - end_pos_types_z (list of int) - list of Z - type of atoms, which could be considered as final positions in vacancy creation mode</span>

<span class="sd">        - calc_method (list)</span>
<span class="sd">            - &#39;neb&#39;</span>
<span class="sd">            - &#39;only_neb&#39; - run only footer</span>

<span class="sd">        - x_start, x_final (array) - explicit xcart coordinates of moving atom for starting and final positions, combined with atom_to_insert</span>
<span class="sd">        - xr_start, xr_final (array) - explicit xred</span>
<span class="sd">        - rep_moving_atom (str)- replace moving atom by needed atom - can be useful than completly different atom is needed. </span>

<span class="sd">        - upload_vts (bool) - if True upload Vasp.pm and nebmake.pl to server</span>
<span class="sd">        - run (bool)  - run on server</span>

<span class="sd">    ###RETURN:</span>
<span class="sd">        None</span>

<span class="sd">    ###DEPENDS:</span>

<span class="sd">    ###TODO</span>
<span class="sd">    1. Take care of manually provided i_atom_to_move in case of replicate flag using init_numbers </span>
<span class="sd">    2. For search_type == None x_m and x_del should be determined for magnetic searching and for saving their coordinates</span>
<span class="sd">    to struct_des; now their just (0,0,0) </span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">old_behaviour</span><span class="p">:</span>
        <span class="n">naming_conventions209</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1">#</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">naming_conventions209</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># set False to reproduce old behavior before 2.09.2017</span>

    <span class="c1"># print(atom_to_insert)</span>
    <span class="c1"># sys.exit()</span>

    <span class="n">calc</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">calc</span>
    <span class="n">struct_des</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">struct_des</span>
    <span class="n">varset</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">varset</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">add_loop_dic</span><span class="p">:</span>
        <span class="n">add_loop_dic</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">end_pos_types_z</span><span class="p">:</span>
        <span class="n">end_pos_types_z</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">calc_method</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
        <span class="n">calc_method</span> <span class="o">=</span> <span class="p">[</span><span class="n">calc_method</span><span class="p">]</span>



    <span class="k">if</span> <span class="n">starting_calc</span> <span class="ow">and</span> <span class="n">st</span><span class="p">:</span>
        <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Warning! both *starting_calc* and *st* are provided. I use *starting_calc*&#39;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">starting_calc</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">starting_calc</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">starting_calc</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
        <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;I use *starting_calc*&#39;</span><span class="p">)</span>


    <span class="k">elif</span> <span class="n">st</span><span class="p">:</span>
        <span class="s1">&#39;&#39;</span>
        <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;I use *st*&#39;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Error! no input structure. Use either *starting_calc* or *st*&#39;</span><span class="p">)</span>



    <span class="k">if</span> <span class="n">corenum</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">images</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">corenum</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="k">elif</span> <span class="n">images</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">corenum</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="k">elif</span> <span class="n">images</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
            <span class="n">corenum</span> <span class="o">=</span> <span class="mi">14</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;add_neb(): Error! number of images&#39;</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span><span class="s1">&#39;is unknown to me; please provide corenum!&#39;</span><span class="p">)</span>



    <span class="c1"># print(atom_to_insert)</span>
    <span class="c1"># sys.exit()</span>


    <span class="k">if</span> <span class="n">corenum</span><span class="p">:</span>
        <span class="c1"># header.corenum = corenum</span>
        <span class="s1">&#39;&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">corenum</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">CORENUM</span>

    <span class="k">if</span> <span class="n">corenum</span> <span class="o">%</span> <span class="n">images</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;Error! Number of cores should be dividable by number of IMAGES&#39;</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">corenum</span><span class="p">)</span>


    <span class="k">if</span> <span class="ow">not</span> <span class="n">ise_new</span><span class="p">:</span>
        <span class="n">ise_new</span> <span class="o">=</span> <span class="n">starting_calc</span><span class="o">.</span><span class="n">id</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;I use&#39;</span><span class="p">,</span> <span class="n">ise_new</span><span class="p">,</span> <span class="s1">&#39;as ise_new&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>


    <span class="n">name_suffix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">st_pores</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">name_suffix</span><span class="o">+=</span><span class="s1">&#39;n&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>


    <span class="sd">&quot;&quot;&quot;Replicate cell &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">replicate</span><span class="p">:</span>
        <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;You have chosen to replicate the structure by&#39;</span><span class="p">,</span> <span class="n">replicate</span><span class="p">)</span>

        <span class="n">st</span> <span class="o">=</span> <span class="n">replic</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">mul</span> <span class="o">=</span> <span class="n">replicate</span><span class="p">)</span>
        <span class="n">name_suffix</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">replicate</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">replicate</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">replicate</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>



    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Search type is &#39;</span><span class="p">,</span> <span class="n">search_type</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">search_type</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="k">if</span> <span class="n">st_end</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Error! You have provided search_type == None, st_end should be provided!&#39;</span><span class="p">)</span>

        <span class="n">st1</span> <span class="o">=</span> <span class="n">st</span>
        <span class="n">st2</span> <span class="o">=</span> <span class="n">st_end</span>

        <span class="n">x_m</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">x_del</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>




    <span class="k">else</span><span class="p">:</span>

        <span class="sd">&quot;&quot;&quot;1. Choose  atom (or insert) for moving &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">xr_start</span><span class="p">):</span>
            <span class="n">x_start</span> <span class="o">=</span> <span class="n">xred2xcart</span><span class="p">([</span><span class="n">xr_start</span><span class="p">],</span> <span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">st1</span><span class="p">,</span> <span class="n">i_m</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">add_atoms</span><span class="p">([</span><span class="n">x_start</span><span class="p">],</span> <span class="n">atom_to_insert</span><span class="p">,</span> <span class="n">return_ins</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">x_m</span> <span class="o">=</span> <span class="n">x_start</span>
            <span class="c1"># i_m = st1.find_atom_num_by_xcart(x_start)</span>
            <span class="c1"># print(st1.get_elements()[i_m])</span>
            <span class="c1"># sys.exit()</span>


            <span class="k">if</span> <span class="n">i_atom_to_move</span><span class="p">:</span>
                <span class="n">nn</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">i_atom_to_move</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nn</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">i_void_start</span><span class="p">)</span>


            <span class="n">name_suffix</span><span class="o">+=</span><span class="n">atom_to_insert</span><span class="o">+</span><span class="n">nn</span>
            <span class="n">write_xyz</span><span class="p">(</span><span class="n">st1</span><span class="p">,</span> <span class="n">file_name</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39;_manually_start&#39;</span><span class="p">)</span>
            <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Start position is created manually by adding xr_start&#39;</span><span class="p">,</span> <span class="n">xr_start</span><span class="p">,</span> <span class="n">x_start</span><span class="p">)</span>
            <span class="n">type_atom_to_move</span> <span class="o">=</span> <span class="n">atom_to_insert</span>
            <span class="n">el_num_suffix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>


        <span class="k">else</span><span class="p">:</span>

            <span class="n">atoms_to_move</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">atoms_to_move_types</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="c1"># print(&#39;d&#39;, i_atom_to_move)</span>
            <span class="c1"># sys.exit()</span>

            <span class="k">if</span> <span class="n">i_atom_to_move</span><span class="p">:</span>
                <span class="n">typ</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">get_elements</span><span class="p">()[</span><span class="n">i_atom_to_move</span><span class="p">]</span>
                <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;add_neb(): atom&#39;</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="s1">&#39;will be moved&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
                <span class="n">atoms_to_move</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i_atom_to_move</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">xcart</span><span class="p">[</span><span class="n">i_atom_to_move</span><span class="p">]])</span>
                <span class="n">atoms_to_move_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span>
    
                <span class="k">if</span> <span class="n">naming_conventions209</span><span class="p">:</span>
                    <span class="n">name_suffix</span><span class="o">+=</span><span class="n">typ</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i_atom_to_move</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>



            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#try to find automatically among alkali - special case for batteries</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">natom</span><span class="p">),</span> <span class="n">st</span><span class="o">.</span><span class="n">get_elements</span><span class="p">(),</span> <span class="n">st</span><span class="o">.</span><span class="n">xcart</span><span class="p">):</span> 
                    <span class="k">if</span> <span class="n">typ</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Li&#39;</span><span class="p">,</span> <span class="s1">&#39;Na&#39;</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="s1">&#39;Rb&#39;</span><span class="p">,</span> <span class="s1">&#39;Mg&#39;</span><span class="p">]:</span>
                        <span class="n">atoms_to_move</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">typ</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atoms_to_move_types</span><span class="p">:</span>
                            <span class="n">atoms_to_move_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span>

            <span class="k">if</span>  <span class="n">atoms_to_move</span><span class="p">:</span>
                <span class="c1"># print(atom_to_move)</span>
                <span class="c1"># sys.exit()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">atom_to_move</span><span class="p">:</span>
                    <span class="n">atom_to_move</span> <span class="o">=</span> <span class="n">atoms_to_move_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># taking first found element</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms_to_move_types</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Error! More than one type of atoms available for moving detected&#39;</span><span class="p">,</span> <span class="n">atoms_to_move_types</span><span class="p">,</span>
                            <span class="s1">&#39;please specify needed atom with *atom_to_move*&#39;</span><span class="p">)</span>

                <span class="n">type_atom_to_move</span> <span class="o">=</span> <span class="n">atom_to_move</span> <span class="c1">#atoms_to_move[0][1]</span>

                <span class="c1"># printlog(&#39;atom &#39;, type_atom_to_move, &#39;will be moved&#39;, imp =&#39;y&#39;)</span>

                <span class="k">if</span> <span class="n">i_atom_to_move</span><span class="p">:</span>
                    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;add_neb(): *i_atom_to_move* = &#39;</span><span class="p">,</span> <span class="n">i_atom_to_move</span><span class="p">,</span> <span class="s1">&#39;is used&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
                    <span class="n">numbers</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i_atom_to_move</span><span class="p">]]</span>
                    <span class="n">i_void_start</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;add_neb(): determine_symmetry_positions ...&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>

                    <span class="n">numbers</span> <span class="o">=</span> <span class="n">determine_symmetry_positions</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">atom_to_move</span><span class="p">)</span>

                <span class="c1"># print(numbers)</span>
                <span class="c1"># sys.exit()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Please choose position using *i_void_start* :&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">))],</span><span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span> <span class="p">)</span>
                    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;*i_void_start* = &#39;</span><span class="p">,</span> <span class="n">i_void_start</span><span class="p">)</span>
                    <span class="n">i_m</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i_void_start</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Position&#39;</span><span class="p">,</span><span class="n">i_void_start</span><span class="p">,</span><span class="s1">&#39;chosen, atom:&#39;</span><span class="p">,</span> <span class="n">i_m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">type_atom_to_move</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span> <span class="p">)</span>
                
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">i_m</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                
                <span class="n">x_m</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">xcart</span><span class="p">[</span><span class="n">i_m</span><span class="p">]</span>

                <span class="n">el_num_suffix</span> <span class="o">=</span>  <span class="n">type_atom_to_move</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i_m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">atom_to_insert</span> <span class="o">=</span> <span class="n">atom_to_move</span>

                <span class="n">st1</span> <span class="o">=</span> <span class="n">st</span>
            <span class="c1"># elif atom_to_replace:</span>
            <span class="c1">#     num = st.get_specific_elements(atom_to_replace)</span>

            <span class="c1">#     if len(n)&gt;0:</span>
            <span class="c1">#         printlog(&#39;Please choose position using *i_void_start* :&#39;, [i+1 for i in range(len(num))],imp = &#39;y&#39; )</span>
            <span class="c1">#         printlog(&#39;*i_void_start* = &#39;, i_void_start)</span>
            <span class="c1">#         i_m = num[i_void_start-1]</span>
            <span class="c1">#         printlog(&#39;Position&#39;,i_void_start,&#39;chosen, atom to replace:&#39;, i_m+1, atom_to_replace, imp = &#39;y&#39; )</span>
            <span class="c1">#         sys.exit()</span>


            <span class="k">else</span><span class="p">:</span>

                <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;No atoms to move found, you probably gave me deintercalated structure&#39;</span><span class="p">,</span> <span class="n">important</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
                
                <span class="n">st_pores</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">avds</span> <span class="o">=</span> <span class="n">determine_voids</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">r_impurity</span><span class="p">,</span> <span class="n">step_dec</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">fine</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
              

                <span class="n">insert_positions</span> <span class="o">=</span> <span class="n">determine_unique_voids</span><span class="p">(</span><span class="n">st_pores</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">avds</span><span class="p">)</span>

                <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;Please use *i_void_start* to choose the void for atom insertion from the Table above:&#39;</span><span class="p">,</span> 
                    <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;Y&#39;</span><span class="p">)</span>


                <span class="k">if</span> <span class="n">i_void_start</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">atom_to_insert</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Error! atom_to_insert = None&#39;</span><span class="p">)</span>

                <span class="n">st</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">add_atoms</span><span class="p">([</span><span class="n">insert_positions</span><span class="p">[</span><span class="n">i_void_start</span><span class="p">],],</span> <span class="n">atom_to_insert</span><span class="p">)</span>

                <span class="n">name_suffix</span><span class="o">+=</span><span class="s1">&#39;i&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i_void_start</span><span class="p">)</span>

                <span class="n">i_m</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">natom</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">x_m</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">xcart</span><span class="p">[</span><span class="n">i_m</span><span class="p">]</span>

                <span class="n">search_type</span> <span class="o">=</span> <span class="s1">&#39;existing_voids&#39;</span>
                <span class="n">type_atom_to_move</span> <span class="o">=</span> <span class="n">atom_to_insert</span>
                <span class="n">el_num_suffix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

                <span class="n">st1</span> <span class="o">=</span> <span class="n">st</span>



        <span class="sd">&quot;&quot;&quot;2. Choose final position&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">xr_final</span><span class="p">):</span>
            <span class="n">x_final</span> <span class="o">=</span> <span class="n">xred2xcart</span><span class="p">([</span><span class="n">xr_final</span><span class="p">],</span> <span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            

            <span class="c1">#old</span>
            <span class="c1">#check if i_atom_to_move should be removed</span>
            <span class="c1"># st2 = st1.del_atom(i_m)</span>
            <span class="c1"># st2 = st2.add_atoms([x_final], atom_to_insert)</span>

            <span class="c1">#new</span>
            <span class="n">st2</span> <span class="o">=</span> <span class="n">st1</span><span class="o">.</span><span class="n">mov_atoms</span><span class="p">(</span><span class="n">i_m</span><span class="p">,</span> <span class="n">x_final</span><span class="p">)</span>


            
            <span class="c1"># st1.printme()</span>
            <span class="c1"># st2.printme()</span>
            <span class="c1"># sys.exit()</span>


            <span class="n">x_del</span> <span class="o">=</span> <span class="n">x_final</span> 
            <span class="n">search_type</span> <span class="o">=</span> <span class="s1">&#39;manual_insertion&#39;</span>
            <span class="n">name_suffix</span><span class="o">+=</span> <span class="s1">&#39;v&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i_void_final</span><span class="p">)</span> 
            <span class="n">write_xyz</span><span class="p">(</span><span class="n">st2</span><span class="p">,</span> <span class="n">file_name</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39;_manually_final&#39;</span><span class="p">)</span>
            <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Final position is created manually by adding xr_final&#39;</span><span class="p">,</span> <span class="n">xr_final</span><span class="p">,</span> <span class="n">x_del</span><span class="p">)</span>



        <span class="k">elif</span> <span class="n">search_type</span> <span class="o">==</span> <span class="s1">&#39;existing_voids&#39;</span><span class="p">:</span>
            <span class="c1">#Search for voids around choosen atoms</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">st_pores</span><span class="p">:</span> 
                <span class="n">st_pores</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">avds</span> <span class="o">=</span> <span class="n">determine_voids</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">r_impurity</span><span class="p">)</span>
            
            <span class="n">sur</span> <span class="o">=</span> <span class="n">determine_unique_final</span><span class="p">(</span><span class="n">st_pores</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">avds</span><span class="p">,</span> <span class="n">x_m</span><span class="p">)</span>

            <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;Please choose *i_void_final* from the Table above:&#39;</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;Y&#39;</span><span class="p">)</span>


            <span class="k">if</span> <span class="n">i_void_final</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

            <span class="n">x_final</span> <span class="o">=</span> <span class="n">sur</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i_void_final</span><span class="p">]</span> <span class="c1">#</span>
            
            <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;You chose:&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x_final</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;Y&#39;</span><span class="p">)</span>


            <span class="n">x_del</span> <span class="o">=</span> <span class="n">x_final</span> <span class="c1">#please compare with vacancy creation mode</span>

            <span class="n">write_xyz</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">add_atoms</span><span class="p">([</span> <span class="n">x_final</span><span class="p">],</span> <span class="s1">&#39;H&#39;</span><span class="p">),</span> <span class="n">replications</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">file_name</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39;_possible_positions2_replicated&#39;</span><span class="p">)</span>
            
            <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;Choosing the closest position as end&#39;</span><span class="p">,</span> <span class="n">important</span> <span class="o">=</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span>

            <span class="n">st1</span> <span class="o">=</span> <span class="n">st</span>

            <span class="n">st2</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">mov_atoms</span><span class="p">(</span><span class="n">i_m</span><span class="p">,</span> <span class="n">x_final</span><span class="p">)</span>
            
            <span class="n">name_suffix</span> <span class="o">+=</span> <span class="n">el_num_suffix</span><span class="o">+</span><span class="s1">&#39;e&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i_void_final</span><span class="p">)</span><span class="o">+</span><span class="n">atom_to_insert</span>

            <span class="n">st1</span> <span class="o">=</span> <span class="n">return_atoms_to_cell</span><span class="p">(</span><span class="n">st1</span><span class="p">)</span>
            <span class="n">st2</span> <span class="o">=</span> <span class="n">return_atoms_to_cell</span><span class="p">(</span><span class="n">st2</span><span class="p">)</span>

            <span class="n">write_xyz</span><span class="p">(</span><span class="n">st1</span><span class="p">,</span> <span class="n">file_name</span> <span class="o">=</span> <span class="n">st1</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="n">name_suffix</span> <span class="o">+</span><span class="s1">&#39;_start&#39;</span><span class="p">)</span>

            <span class="n">write_xyz</span><span class="p">(</span><span class="n">st2</span><span class="p">,</span> <span class="n">file_name</span> <span class="o">=</span> <span class="n">st2</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="n">name_suffix</span> <span class="o">+</span><span class="s1">&#39;_final&#39;</span><span class="p">)</span>


        <span class="k">elif</span> <span class="n">search_type</span> <span class="o">==</span> <span class="s1">&#39;vacancy_creation&#39;</span><span class="p">:</span>
            <span class="c1">#Create vacancy by removing some neibouring atom of the same type </span>
            
            <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;You have chosen vacancy_creation mode of add_neb tool&#39;</span><span class="p">,</span> <span class="n">imp</span><span class="o">=</span> <span class="s1">&#39;Y&#39;</span><span class="p">)</span>

            <span class="n">print_and_log</span><span class="p">(</span> <span class="s1">&#39;Type of atom to move = &#39;</span><span class="p">,</span> <span class="n">type_atom_to_move</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
            <span class="c1"># print &#39;List of left atoms = &#39;, np.array(st.leave_only(type_atom_to_move).xcart)</span>

            <span class="n">sur</span> <span class="o">=</span> <span class="n">local_surrounding</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">n_neighbours</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span> <span class="n">control</span> <span class="o">=</span> <span class="s1">&#39;atoms&#39;</span><span class="p">,</span> 
                <span class="n">only_elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">invert</span><span class="p">(</span><span class="n">type_atom_to_move</span><span class="p">)]</span><span class="o">+</span><span class="n">end_pos_types_z</span><span class="p">,</span>
                <span class="n">periodic</span>  <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="c1">#exclude the atom itself</span>

            <span class="c1"># print(x_m)</span>
            <span class="c1"># print(sur)</span>

            <span class="c1"># st.nn()</span>
            <span class="n">print_and_log</span><span class="p">(</span>
            <span class="s1">&#39;I can suggest you &#39;</span><span class="o">+</span><span class="nb">str</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sur</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span> <span class="p">)</span><span class="o">+</span><span class="s1">&#39; end positions. The distances to them are : &#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">sur</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">2</span><span class="p">),</span> <span class="s1">&#39; A</span><span class="se">\n</span><span class="s1"> &#39;</span><span class="p">,</span>
            <span class="s1">&#39;They are &#39;</span><span class="p">,</span> <span class="n">type_atom_to_move</span><span class="p">,</span> <span class="p">[</span><span class="n">invert</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">end_pos_types_z</span><span class="p">],</span> <span class="s1">&#39;atoms, use *i_void_final* to choose required: 1, 2, 3 ..&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>


            <span class="k">if</span> <span class="ow">not</span> <span class="n">i_void_final</span><span class="p">:</span>
                <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Changing i_void_final: None -&gt; 1&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
                <span class="n">i_void_final</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1">#since zero is itself</span>

            <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;Choosing position &#39;</span><span class="p">,</span> <span class="n">i_void_final</span><span class="p">,</span> <span class="s1">&#39;with distance&#39;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">sur</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">i_void_final</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>

            <span class="n">name_suffix</span> <span class="o">+=</span> <span class="n">el_num_suffix</span><span class="o">+</span><span class="s1">&#39;v&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i_void_final</span><span class="p">)</span>

            <span class="n">x_del</span> <span class="o">=</span> <span class="n">sur</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i_void_final</span><span class="p">]</span>
            <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;xcart of atom to delete&#39;</span><span class="p">,</span> <span class="n">x_del</span><span class="p">)</span>
            <span class="n">i_del</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">find_atom_num_by_xcart</span><span class="p">(</span><span class="n">x_del</span><span class="p">)</span>
            <span class="c1"># print(x_del)</span>
            <span class="c1"># print(st.xcart)</span>
            <span class="c1"># for x in st.xcart:</span>
            <span class="c1">#     if x[0] &gt; 10:</span>
            <span class="c1">#         print(x)</span>


            <span class="n">print_and_log</span><span class="p">(</span> <span class="s1">&#39;number of atom to delete = &#39;</span><span class="p">,</span> <span class="n">i_del</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i_del</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;add_neb(): Error! I could find atom to delete!&#39;</span><span class="p">)</span>

            <span class="c1"># print st.magmom</span>
            <span class="c1"># print st1.magmom</span>


            <span class="c1"># try:</span>
            <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">xr_start</span><span class="p">):</span>
                <span class="n">st2</span> <span class="o">=</span> <span class="n">st1</span><span class="o">.</span><span class="n">mov_atoms</span><span class="p">(</span><span class="n">i_m</span><span class="p">,</span> <span class="n">x_del</span><span class="p">)</span> <span class="c1"># i_m and sur[0][neb_config] should coincide</span>
                <span class="c1"># i_del = st1.find_atom_num_by_xcart(x_del)</span>
                
                <span class="n">st1</span> <span class="o">=</span> <span class="n">st1</span><span class="o">.</span><span class="n">del_atom</span><span class="p">(</span><span class="n">i_del</span><span class="p">)</span> 

            <span class="k">else</span><span class="p">:</span>
                <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;Making vacancy at end position for starting configuration&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
                <span class="n">st1</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">del_atom</span><span class="p">(</span><span class="n">i_del</span><span class="p">)</span> 


                <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;Making vacancy at start position for final configuration&#39;</span><span class="p">,</span> <span class="n">important</span> <span class="o">=</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span>
                <span class="n">st2</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">mov_atoms</span><span class="p">(</span><span class="n">i_m</span><span class="p">,</span> <span class="n">x_del</span><span class="p">)</span> <span class="c1"># i_m and sur[0][neb_config] should coincide</span>
            <span class="c1"># except:</span>
                <span class="c1"># st2 = st</span>

            <span class="n">st2</span> <span class="o">=</span> <span class="n">st2</span><span class="o">.</span><span class="n">del_atom</span><span class="p">(</span><span class="n">i_del</span><span class="p">)</span> <span class="c1"># these two steps provide the same order</span>



    <span class="sd">&quot;&quot;&quot;Checking correctness of path&quot;&quot;&quot;</span>
    <span class="c1">#if start and final positions are used, collisions with existing atoms are possible </span>
    <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">xr_start</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">xr_final</span><span class="p">):</span>
        <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Checking correctness&#39;</span><span class="p">)</span>
        <span class="n">st1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">st1</span><span class="o">.</span><span class="n">remove_close_lying</span><span class="p">()</span>

        <span class="n">stt</span> <span class="o">=</span> <span class="n">st1</span><span class="o">.</span><span class="n">add_atoms</span><span class="p">([</span><span class="n">x_final</span><span class="p">,],</span> <span class="s1">&#39;Pu&#39;</span><span class="p">)</span>
        <span class="n">stt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stt</span><span class="o">.</span><span class="n">remove_close_lying</span><span class="p">(</span><span class="n">rm_both</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="c1"># now the final position is empty for sure; however the order can be spoiled</span>
        <span class="c1"># print(st._removed)</span>
        <span class="k">if</span> <span class="n">stt</span><span class="o">.</span><span class="n">_removed</span><span class="p">:</span>
            <span class="n">st1</span> <span class="o">=</span> <span class="n">stt</span> <span class="c1"># only if overlapping was found we assign new structure</span>


        <span class="n">st2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">st2</span><span class="o">.</span><span class="n">remove_close_lying</span><span class="p">(</span><span class="n">rm_first</span> <span class="o">=</span> <span class="n">stt</span><span class="o">.</span><span class="n">_removed</span><span class="p">)</span>
        <span class="n">stt</span> <span class="o">=</span> <span class="n">st2</span><span class="o">.</span><span class="n">add_atoms</span><span class="p">([</span><span class="n">x_start</span><span class="p">,],</span> <span class="s1">&#39;Pu&#39;</span><span class="p">)</span>
        <span class="n">stt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stt</span><span class="o">.</span><span class="n">remove_close_lying</span><span class="p">(</span><span class="n">rm_both</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="c1"># now the start position is empty for sure</span>
        <span class="k">if</span> <span class="n">stt</span><span class="o">.</span><span class="n">_removed</span><span class="p">:</span>
            <span class="n">st2</span> <span class="o">=</span> <span class="n">stt</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">st2</span><span class="o">.</span><span class="n">get_elements</span><span class="p">())</span>
        <span class="c1"># sys.exit()</span>


    <span class="k">elif</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">xr_final</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">xr_start</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">xr_start</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">xr_final</span><span class="p">):</span>
        <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Attention! only start of final position is provided, please check that everything is ok with start and final states!!!&#39;</span><span class="p">)</span>





    <span class="sd">&quot;&quot;&quot; Determining magnetic moments  &quot;&quot;&quot;</span>
    <span class="n">vp</span> <span class="o">=</span> <span class="n">varset</span><span class="p">[</span><span class="n">ise_new</span><span class="p">]</span><span class="o">.</span><span class="n">vasp_params</span>



    <span class="k">if</span> <span class="s1">&#39;ISPIN&#39;</span> <span class="ow">in</span> <span class="n">vp</span> <span class="ow">and</span> <span class="n">vp</span><span class="p">[</span><span class="s1">&#39;ISPIN&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;Magnetic calculation detected. Preparing spin modifications ...&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
        <span class="n">cl_test</span> <span class="o">=</span> <span class="n">CalculationVasp</span><span class="p">(</span><span class="n">varset</span><span class="p">[</span><span class="n">ise_new</span><span class="p">])</span>
        <span class="n">cl_test</span><span class="o">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">st1</span>
        <span class="c1"># print &#39;asdfsdfasdfsadfsadf&#39;, st1.magmom</span>
        <span class="k">if</span> <span class="n">inherit_magmom</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="s1">&#39;magmom&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">st</span><span class="o">.</span><span class="n">magmom</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">magmom</span><span class="p">):</span>
            <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;inherit_magmom=True: You have chosen MAGMOM from provided structure&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
            <span class="n">name_suffix</span><span class="o">+=</span><span class="s1">&#39;mp&#39;</span> <span class="c1">#Magmom from Previous</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cl_test</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">magmom</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;inherit_magmom=False or no magmom in input structure : MAGMOM will be determined  from set&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
            <span class="n">name_suffix</span><span class="o">+=</span><span class="s1">&#39;ms&#39;</span> <span class="c1">#Magmom from Set</span>


        <span class="n">cl_test</span><span class="o">.</span><span class="n">actualize_set</span><span class="p">()</span> <span class="c1">#find magmom for current structure</span>

        <span class="n">st1</span><span class="o">.</span><span class="n">magmom</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">cl_test</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">magmom</span><span class="p">)</span>
        <span class="n">st2</span><span class="o">.</span><span class="n">magmom</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">cl_test</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">magmom</span><span class="p">)</span>

        <span class="c1"># sys.exit()</span>
        <span class="c1"># print_and_log(&#39;The magnetic moments from set:&#39;)</span>
        <span class="c1"># print cl_test.init.magmom</span>
        <span class="k">if</span> <span class="n">search_type</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># for None not implemented; x_m should be determined first for this</span>
            <span class="c1">#checking for closest atoms now only for Fe, Mn, Ni, Co</span>
            <span class="n">sur</span>   <span class="o">=</span> <span class="n">local_surrounding</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="n">st1</span><span class="p">,</span> <span class="n">n_neighbours</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">control</span> <span class="o">=</span> <span class="s1">&#39;atoms&#39;</span><span class="p">,</span>
            <span class="n">periodic</span>  <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">only_elements</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">TRANSITION_ELEMENTS</span><span class="p">)</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sur</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">numb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sur</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">a</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">numb</span><span class="p">,</span> <span class="n">dist</span> <span class="p">)</span>
            <span class="c1"># a=  np.array(a)</span>
            <span class="c1"># print a[1]</span>
            <span class="c1"># a = np.apply_along_axis(np.unique, 1, a)</span>
            <span class="c1"># print a</span>
            <span class="k">def</span> <span class="nf">unique_by_key</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># no key: the whole element must be unique</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span>
                <span class="k">return</span> <span class="nb">list</span> <span class="p">(</span> <span class="p">{</span><span class="n">key</span><span class="p">(</span><span class="n">el</span><span class="p">):</span> <span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">}</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="p">)</span>

            <span class="c1"># print a</span>
            <span class="n">mag_atoms_dists</span> <span class="o">=</span> <span class="n">unique_by_key</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="c1"># print (mag_atoms_dists)</span>
            <span class="c1"># a = unique_by_key(a, key=itemgetter(1))</span>
            <span class="n">print_and_log</span><span class="p">(</span> <span class="s1">&#39;I change spin for the following atoms:</span><span class="se">\n</span><span class="s1">i atom     dist</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">mag_atoms_dists</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span> <span class="p">)</span>
            <span class="c1"># print &#39;I have found closest Fe atoms&#39;</span>
            <span class="n">muls</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)]</span>
            <span class="n">mag_moments_variants</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">mm</span> <span class="ow">in</span> <span class="n">muls</span><span class="p">:</span>
                <span class="n">mags</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">cl_test</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">magmom</span><span class="p">)</span>
                <span class="c1"># print mags</span>
                <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mag_atoms_dists</span><span class="p">,</span> <span class="n">mm</span><span class="p">):</span>
                    <span class="c1"># print t[1]</span>
                    <span class="n">mags</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">mags</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">*</span><span class="n">m</span>
                <span class="n">mag_moments_variants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mags</span><span class="p">)</span>

            <span class="n">print_and_log</span><span class="p">(</span> <span class="s1">&#39;The list of possible mag_moments:&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mag</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mag_moments_variants</span><span class="p">):</span>
                <span class="n">print_and_log</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">mag</span><span class="p">)</span>

            <span class="n">print_and_log</span><span class="p">(</span> <span class="s1">&#39;Please use *mag_config* arg to choose desired config&#39;</span> <span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span> <span class="p">)</span>


        <span class="k">if</span> <span class="n">mag_config</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">st1</span><span class="o">.</span><span class="n">magmom</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mag_moments_variants</span><span class="p">[</span><span class="n">mag_config</span><span class="p">])</span>
            <span class="n">st2</span><span class="o">.</span><span class="n">magmom</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mag_moments_variants</span><span class="p">[</span><span class="n">mag_config</span><span class="p">])</span>

            <span class="n">name_suffix</span><span class="o">+=</span><span class="s1">&#39;m&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">mag_config</span><span class="p">)</span>

            <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;You have chosen mag configuration #&#39;</span><span class="p">,</span><span class="n">mag_config</span><span class="p">,</span><span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;Non-magnetic calculation continue ...&#39;</span><span class="p">)</span>















    <span class="sd">&quot;&quot;&quot;3. Add to struct_des, create geo files, check set, add_loop &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">starting_calc</span><span class="p">:</span>
        <span class="n">it</span> <span class="o">=</span> <span class="n">starting_calc</span><span class="o">.</span><span class="n">id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">it_new</span> <span class="o">=</span> <span class="n">it</span><span class="o">+</span><span class="s1">&#39;v&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">starting_calc</span><span class="o">.</span><span class="n">id</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">name_suffix</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">it_new_folder</span><span class="p">:</span>
            <span class="n">it_new_folder</span> <span class="o">=</span> <span class="n">struct_des</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="o">.</span><span class="n">sfolder</span><span class="o">+</span><span class="s1">&#39;/neb/&#39;</span>
        <span class="n">obtained_from</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">starting_calc</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> 

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ise_new</span><span class="p">:</span>
            <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;I will run add_loop() using the same set&#39;</span><span class="p">,</span> <span class="n">important</span> <span class="o">=</span> <span class="s1">&#39;Y&#39;</span><span class="p">)</span>
            <span class="n">ise_new</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="n">id</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">st</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">it_new</span><span class="p">:</span>
            <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Error! please provide *it_new* - name for your calculation&#39;</span><span class="p">,</span> <span class="n">important</span> <span class="o">=</span> <span class="s1">&#39;Y&#39;</span><span class="p">)</span>


        <span class="n">it</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">it_new</span><span class="o">+=</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">name_suffix</span>
        <span class="n">obtained_from</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">name</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ise_new</span><span class="p">:</span>
            <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Error! please provide *ise_new*&#39;</span><span class="p">,</span> <span class="n">important</span> <span class="o">=</span> <span class="s1">&#39;Y&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">it_new_folder</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">it_folder</span><span class="p">:</span>
            
            <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Error! please provide *it_new_folder* - folder for your new calculation&#39;</span><span class="p">,</span> <span class="n">important</span> <span class="o">=</span> <span class="s1">&#39;Y&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">it_folder</span><span class="p">:</span>
            <span class="n">it_new_folder</span> <span class="o">=</span> <span class="n">it_folder</span>

    <span class="k">if</span> <span class="n">rep_moving_atom</span><span class="p">:</span>
        <span class="n">it_new</span> <span class="o">+=</span> <span class="s1">&#39;r&#39;</span><span class="o">+</span><span class="n">rep_moving_atom</span>

    <span class="k">if</span> <span class="n">it_new</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">struct_des</span><span class="p">:</span>
        <span class="n">add_des</span><span class="p">(</span><span class="n">struct_des</span><span class="p">,</span> <span class="n">it_new</span><span class="p">,</span> <span class="n">it_new_folder</span><span class="p">,</span> <span class="s1">&#39;Automatically created and added from &#39;</span><span class="o">+</span><span class="n">obtained_from</span>  <span class="p">)</span>




    <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;Creating geo files for starting and final configurations (versions 1 and 2) &#39;</span><span class="p">,</span> <span class="n">important</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>

    <span class="c1"># if starting_calc:</span>
    <span class="c1">#     cl = copy.deepcopy(starting_calc)</span>
    <span class="c1"># else:</span>

    <span class="n">cl</span> <span class="o">=</span> <span class="n">CalculationVasp</span><span class="p">()</span>

    <span class="c1">#write start position</span>
    <span class="k">if</span> <span class="n">search_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">struct_des</span><span class="p">[</span><span class="n">it_new</span><span class="p">]</span><span class="o">.</span><span class="n">x_m_ion_start</span> <span class="o">=</span> <span class="n">x_m</span>
        <span class="n">struct_des</span><span class="p">[</span><span class="n">it_new</span><span class="p">]</span><span class="o">.</span><span class="n">xr_m_ion_start</span> <span class="o">=</span> <span class="n">xcart2xred</span><span class="p">([</span><span class="n">x_m</span><span class="p">],</span> <span class="n">st1</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># st1, _, _ = st1.remove_close_lying()</span>
        <span class="c1"># st2, _, _ = st2.remove_close_lying()</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="n">st1</span><span class="o">.</span><span class="n">find_atom_num_by_xcart</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="n">prec</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">)</span>
        <span class="n">i2</span> <span class="o">=</span> <span class="n">st2</span><span class="o">.</span><span class="n">find_atom_num_by_xcart</span><span class="p">(</span><span class="n">x_del</span><span class="p">,</span> <span class="n">prec</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rep_moving_atom</span><span class="p">:</span> <span class="c1">#replace the moving atom by required</span>
            <span class="n">st1</span> <span class="o">=</span> <span class="n">st1</span><span class="o">.</span><span class="n">replace_atoms</span><span class="p">([</span><span class="n">i1</span><span class="p">],</span> <span class="n">rep_moving_atom</span><span class="p">)</span>
            <span class="n">st2</span> <span class="o">=</span> <span class="n">st2</span><span class="o">.</span><span class="n">replace_atoms</span><span class="p">([</span><span class="n">i2</span><span class="p">],</span> <span class="n">rep_moving_atom</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#allows to make correct order for nebmake.pl</span>
            <span class="n">st1</span> <span class="o">=</span> <span class="n">st1</span><span class="o">.</span><span class="n">replace_atoms</span><span class="p">([</span><span class="n">i1</span><span class="p">],</span> <span class="n">type_atom_to_move</span><span class="p">)</span>
            <span class="n">st2</span> <span class="o">=</span> <span class="n">st2</span><span class="o">.</span><span class="n">replace_atoms</span><span class="p">([</span><span class="n">i2</span><span class="p">],</span> <span class="n">type_atom_to_move</span><span class="p">)</span>

        <span class="n">i1</span> <span class="o">=</span> <span class="n">st1</span><span class="o">.</span><span class="n">find_atom_num_by_xcart</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="n">prec</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">)</span> <span class="c1"># the positions were changed # check if this is correct</span>
        <span class="n">i2</span> <span class="o">=</span> <span class="n">st2</span><span class="o">.</span><span class="n">find_atom_num_by_xcart</span><span class="p">(</span><span class="n">x_del</span><span class="p">,</span> <span class="n">prec</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">)</span>


    <span class="n">cl</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">st1</span>
    <span class="n">ver_new</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">cl</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">ver_new</span>
    <span class="n">cl</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="s2">&quot;input_geo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">geo_folder</span> <span class="o">+</span> <span class="n">struct_des</span><span class="p">[</span><span class="n">it_new</span><span class="p">]</span><span class="o">.</span><span class="n">sfolder</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> \
        <span class="n">it_new</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="n">it_new</span><span class="o">+</span><span class="s1">&#39;.auto_created_starting_position_for_neb_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">search_type</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ver_new</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="s1">&#39;geo&#39;</span>
    
    <span class="n">cl</span><span class="o">.</span><span class="n">write_siman_geo</span><span class="p">(</span><span class="n">geotype</span> <span class="o">=</span> <span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s1">&#39;Starting conf. for neb from &#39;</span><span class="o">+</span><span class="n">obtained_from</span><span class="p">,</span> <span class="n">override</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>


    <span class="c1">#write final position</span>

    <span class="n">struct_des</span><span class="p">[</span><span class="n">it_new</span><span class="p">]</span><span class="o">.</span><span class="n">x_m_ion_final</span> <span class="o">=</span> <span class="n">x_del</span>
    <span class="n">struct_des</span><span class="p">[</span><span class="n">it_new</span><span class="p">]</span><span class="o">.</span><span class="n">xr_m_ion_final</span> <span class="o">=</span> <span class="n">xcart2xred</span><span class="p">([</span><span class="n">x_del</span><span class="p">],</span> <span class="n">st2</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>



    <span class="n">cl</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">st2</span>
    <span class="n">ver_new</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">cl</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">ver_new</span>
    <span class="n">cl</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="s2">&quot;input_geo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">geo_folder</span> <span class="o">+</span> <span class="n">struct_des</span><span class="p">[</span><span class="n">it_new</span><span class="p">]</span><span class="o">.</span><span class="n">sfolder</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> \
        <span class="n">it_new</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="n">it_new</span><span class="o">+</span><span class="s1">&#39;.auto_created_final_position_for_neb_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">search_type</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ver_new</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="s1">&#39;geo&#39;</span>
    
    <span class="n">cl</span><span class="o">.</span><span class="n">write_siman_geo</span><span class="p">(</span><span class="n">geotype</span> <span class="o">=</span> <span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s1">&#39;Final conf. for neb from &#39;</span><span class="o">+</span><span class="n">obtained_from</span><span class="p">,</span> <span class="n">override</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">rep_moving_atom</span> <span class="ow">and</span> <span class="n">search_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">st1s</span> <span class="o">=</span> <span class="n">st1</span><span class="o">.</span><span class="n">replace_atoms</span><span class="p">([</span><span class="n">i1</span><span class="p">],</span> <span class="s1">&#39;Pu&#39;</span><span class="p">)</span>
        <span class="n">st2s</span> <span class="o">=</span> <span class="n">st2</span><span class="o">.</span><span class="n">replace_atoms</span><span class="p">([</span><span class="n">i2</span><span class="p">],</span> <span class="s1">&#39;Pu&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">st1s</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">st1</span><span class="p">)</span>
        <span class="n">st2s</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">st2</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">center_on_moving</span> <span class="ow">and</span> <span class="n">search_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="n">st1</span><span class="o">.</span><span class="n">center_on</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span>
        <span class="n">st1s</span> <span class="o">=</span> <span class="n">st1s</span><span class="o">.</span><span class="n">shift_atoms</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
        <span class="n">st2s</span> <span class="o">=</span> <span class="n">st2s</span><span class="o">.</span><span class="n">shift_atoms</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
        <span class="n">write_xyz</span><span class="p">(</span><span class="n">st1s</span><span class="p">,</span> <span class="n">file_name</span> <span class="o">=</span> <span class="n">it_new</span><span class="o">+</span><span class="s1">&#39;_start&#39;</span><span class="p">)</span>
        <span class="n">write_xyz</span><span class="p">(</span><span class="n">st2s</span><span class="p">,</span> <span class="n">file_name</span> <span class="o">=</span> <span class="n">it_new</span><span class="o">+</span><span class="s1">&#39;_end&#39;</span><span class="p">)</span>


    <span class="n">st1s</span><span class="o">.</span><span class="n">write_poscar</span><span class="p">(</span><span class="s1">&#39;xyz/POSCAR1&#39;</span><span class="p">)</span>
    <span class="n">st2s</span><span class="o">.</span><span class="n">write_poscar</span><span class="p">(</span><span class="s1">&#39;xyz/POSCAR2&#39;</span><span class="p">)</span>
    <span class="c1"># print(a)</span>
    <span class="c1"># runBash(&#39;cd xyz; mkdir &#39;+it_new+&#39;_all;&#39;+&quot;&quot;&quot;for i in {00..04}; do cp $i/POSCAR &quot;&quot;&quot;+ it_new+&#39;_all/POSCAR$i; done; rm -r 00 01 02 03 04&#39;)</span>
    
    <span class="k">with</span> <span class="n">cd</span><span class="p">(</span><span class="s1">&#39;xyz&#39;</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">runBash</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">PATH2NEBMAKE</span><span class="o">+</span><span class="s1">&#39; POSCAR1 POSCAR2 3&#39;</span><span class="p">)</span>
        
        <span class="n">dst</span> <span class="o">=</span> <span class="n">it_new</span><span class="o">+</span><span class="s1">&#39;_all&#39;</span>
        <span class="n">makedir</span><span class="p">(</span><span class="n">dst</span><span class="o">+</span><span class="s1">&#39;/any&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;00&#39;</span><span class="p">,</span> <span class="s1">&#39;01&#39;</span><span class="p">,</span> <span class="s1">&#39;02&#39;</span><span class="p">,</span> <span class="s1">&#39;03&#39;</span><span class="p">,</span> <span class="s1">&#39;04&#39;</span><span class="p">]:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="o">+</span><span class="s1">&#39;/POSCAR&#39;</span><span class="p">,</span> <span class="n">dst</span><span class="o">+</span><span class="s1">&#39;/POSCAR&#39;</span><span class="o">+</span><span class="n">f</span><span class="p">)</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>





    <span class="c1">#prepare calculations</span>
    <span class="c1"># sys.exit()</span>








    <span class="c1">#Check if nebmake is avail</span>
    <span class="c1"># if int(runBash(&#39;ssh &#39;+cluster_address+&#39; test -e &#39;+project_path_cluster+&#39;/tools/vts/nebmake.pl; echo $?&#39;) ):</span>

    <span class="c1">#     &#39;&#39;</span>
    <span class="c1">#     print_and_log(&#39;Please upload vtsttools to &#39;,cluster_address, project_path_cluster+&#39;/tools/vts/&#39;)</span>
    <span class="c1">#     raise RuntimeError</span>

    <span class="c1">#     copy_to_server(path_to_wrapper+&#39;/vtstscripts/nebmake.pl&#39;, to = project_path_cluster+&#39;/tools/&#39;,  addr = cluster_address)</span>
    <span class="c1"># if  int(runBash(&#39;ssh &#39;+cluster_address+&#39; test -e &#39;+project_path_cluster+&#39;/tools/Vasp.pm; echo $?&#39;) ):</span>
    <span class="c1">#     copy_to_server(path_to_wrapper+&#39;/vtstscripts/Vasp.pm&#39;, to = project_path_cluster+&#39;/tools/&#39;,  addr = cluster_address)</span>





    <span class="n">inherit_ngkpt</span><span class="p">(</span><span class="n">it_new</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="n">varset</span><span class="p">[</span><span class="n">ise_new</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">run</span><span class="p">:</span>
        <span class="n">add_loop_dic</span><span class="p">[</span><span class="s1">&#39;run&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">run</span>


    <span class="n">add_loop</span><span class="p">(</span><span class="n">it_new</span><span class="p">,</span> <span class="n">ise_new</span><span class="p">,</span> <span class="n">verlist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">up</span> <span class="o">=</span> <span class="n">up</span><span class="p">,</span> <span class="n">calc_method</span> <span class="o">=</span> <span class="n">calc_method</span><span class="p">,</span> <span class="n">savefile</span> <span class="o">=</span> <span class="s1">&#39;oc&#39;</span><span class="p">,</span> <span class="n">inherit_option</span> <span class="o">=</span> <span class="n">inherit_option</span><span class="p">,</span> <span class="n">n_neb_images</span> <span class="o">=</span> <span class="n">images</span><span class="p">,</span> <span class="n">corenum</span> <span class="o">=</span> <span class="n">corenum</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">add_loop_dic</span>  <span class="p">)</span>
    

    <span class="k">if</span> <span class="n">upload_vts</span><span class="p">:</span>
        <span class="n">siman_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
        <span class="c1"># print(upload_vts)</span>
        <span class="n">push_to_server</span><span class="p">([</span><span class="n">siman_dir</span><span class="o">+</span><span class="s1">&#39;/cluster_tools/nebmake.pl&#39;</span><span class="p">,</span> <span class="n">siman_dir</span><span class="o">+</span><span class="s1">&#39;/cluster_tools/Vasp.pm&#39;</span><span class="p">],</span> <span class="n">to</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">cluster_home</span><span class="o">+</span><span class="s1">&#39;/tools/vts&#39;</span><span class="p">,</span>  <span class="n">addr</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">cluster_address</span><span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;Please be sure that vtsttools are at&#39;</span><span class="p">,</span><span class="n">header</span><span class="o">.</span><span class="n">cluster_address</span><span class="p">,</span> <span class="n">header</span><span class="o">.</span><span class="n">cluster_home</span><span class="o">+</span><span class="s1">&#39;/tools/vts/&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;Y&#39;</span><span class="p">)</span>

    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;add_neb finished&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">it_new</span> </div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../../index.html">Table of Contents</a></h3>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Siman 0.9.5 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Dmitry Aksenov.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.1.
    </div>
  </body>
</html>