
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>siman.geo &#8212; Siman 0.9.5 documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Siman 0.9.5 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for siman.geo</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">copy</span><span class="o">,</span> <span class="nn">itertools</span><span class="o">,</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">itemgetter</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">tabulate</span> <span class="k">import</span> <span class="n">tabulate</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;geo.py:tabulate is not avail&#39;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">siman</span> <span class="k">import</span> <span class="n">header</span>
<span class="kn">from</span> <span class="nn">siman.header</span> <span class="k">import</span> <span class="n">printlog</span>
<span class="kn">from</span> <span class="nn">siman.small_functions</span> <span class="k">import</span> <span class="n">red_prec</span>
<span class="c1"># from impurity import find_pores</span>

<span class="c1"># sys.path.append(&#39;/home/aksenov/Simulation_wrapper/&#39;) </span>
<span class="c1"># sys.path.append(&#39;/home/aksenov/Simulation_wrapper/savelyev&#39;) </span>



<div class="viewcode-block" id="image_distance"><a class="viewcode-back" href="../../siman.html#siman.geo.image_distance">[docs]</a><span class="k">def</span> <span class="nf">image_distance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sort_flag</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">return_n_distances</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate smallest distance and the next smallest distance between two atoms </span>
<span class="sd">    correctly treating periodic boundary conditions and oblique cells.</span>
<span class="sd">    x1, x2 - vector[3] xcart coordinates of two atoms</span>
<span class="sd">    r - rprimd of cell</span>
<span class="sd">    order - the order of periodic images which are accounted in the calcualtion of distances between atoms.</span>
<span class="sd">    for cubic cells, order = 1 always provide correct result.</span>
<span class="sd">    For highly oblique cell you should test and find the needed value of &#39;order&#39; after which results are the same.</span>
<span class="sd">    sort_flag (bool) - use False if you do not need sorting of distances </span>

<span class="sd">    return_n_distances(bool) - returns required number of smallest distances, depending on order</span>

<span class="sd">    return d1, d2 - the smallest and next smallest distances between atoms</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># list of distances between 1st atom and images of 2nd atom</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">order</span><span class="p">,</span> <span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">order</span><span class="p">,</span> <span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">order</span><span class="p">,</span> <span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">x2i</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span> <span class="c1">#determine coordinates of image of atom 2 in corresponding image cells</span>
                <span class="n">d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>   <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2i</span><span class="p">)</span>   <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">sort_flag</span><span class="p">:</span>
        <span class="n">d</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="c1">#print d</span>
    <span class="c1"># assert d[0] == min(d)</span>

    <span class="k">if</span> <span class="n">return_n_distances</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">return_n_distances</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># old behaviour</span></div>


<div class="viewcode-block" id="scale_cell_uniformly"><a class="viewcode-back" href="../../siman.html#siman.geo.scale_cell_uniformly">[docs]</a><span class="k">def</span> <span class="nf">scale_cell_uniformly</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">scale_region</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">n_scale_images</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">parent_calc_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scale uniformly rprimd and xcart of structure() object *st* from *scale_region[0]* to *scale_region[1]*  (%) using *n_scale_images* images.</span>
<span class="sd">    *parent_calc_name* is added to st.des</span>
<span class="sd">    Return:</span>
<span class="sd">    list of scaled Structure() objects</span>
<span class="sd">    </span>
<span class="sd">    TODO: Take care of vol, recip and so on - the best is to create some method st.actual() that update all information </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># print scale_region</span>
    <span class="n">scales</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">scale_region</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scale_region</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_scale_images</span><span class="p">)</span>
    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Scales are&#39;</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>

    <span class="c1"># print scales</span>
    <span class="n">scaled_sts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scales</span><span class="p">):</span>
        <span class="n">st_s</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">st_s</span><span class="o">.</span><span class="n">rprimd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">s</span><span class="o">/</span><span class="mf">100.</span><span class="p">)</span>
        <span class="c1"># print st_s.rprimd</span>

        <span class="n">st_s</span><span class="o">.</span><span class="n">xred2xcart</span><span class="p">()</span>
        <span class="n">st_s</span><span class="o">.</span><span class="n">des</span> <span class="o">=</span> <span class="s1">&#39;obtained from &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">parent_calc_name</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; by uniform scaling by &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; %&#39;</span>
        <span class="n">st_s</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">scaled_sts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">st_s</span><span class="p">)</span>
        <span class="c1"># print st_s.rprimd</span>

    <span class="c1"># plt.plot([np.linalg.norm(st.rprimd) for st in scaled_sts])</span>
    <span class="c1"># plt.show()</span>
    <span class="k">return</span> <span class="n">scaled_sts</span></div>

<div class="viewcode-block" id="scale_cell_by_matrix"><a class="viewcode-back" href="../../siman.html#siman.geo.scale_cell_by_matrix">[docs]</a><span class="k">def</span> <span class="nf">scale_cell_by_matrix</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">scale_region</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">n_scale_images</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">parent_calc_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mul_matrix</span> <span class="o">=</span> <span class="kc">None</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scale  rprimd and xcart of structure() object *st* from *scale_region[0]* to *scale_region[1]*  (%) using *n_scale_images* images</span>
<span class="sd">    and mul_matrix.</span>
<span class="sd">    *parent_calc_name* is added to st.des</span>
<span class="sd">    Return:</span>
<span class="sd">    list of scaled Structure() objects</span>
<span class="sd">    </span>
<span class="sd">    TODO: Take care of vol, recip and so on - the best is to create some method st.actual() that update all information </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scales</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">scale_region</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scale_region</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_scale_images</span><span class="p">)</span>

    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Scales are&#39;</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
    <span class="c1"># print(np.asarray(st.rprimd))</span>

    <span class="n">scaled_sts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scales</span><span class="p">):</span>
        <span class="n">st_s</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="c1"># print(s)</span>
        <span class="n">mul_matrix_f</span> <span class="o">=</span> <span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mul_matrix</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">st_s</span><span class="o">.</span><span class="n">rprimd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mul_matrix_f</span><span class="p">,</span> <span class="n">st_s</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)</span>
        <span class="c1"># st_s.rprimd = np.dot(s/100*np.asarray(mul_matrix)+np.identity(3), st_s.rprimd)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">mul_matrix_f</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">st_s</span><span class="o">.</span><span class="n">rprimd</span><span class="p">))</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">st_s</span><span class="o">.</span><span class="n">get_angles</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>    


        <span class="n">st_s</span><span class="o">.</span><span class="n">xred2xcart</span><span class="p">()</span>
        <span class="n">st_s</span><span class="o">.</span><span class="n">des</span> <span class="o">=</span> <span class="s1">&#39;obtained from &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">parent_calc_name</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; by scaling by &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; % &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">mul_matrix</span><span class="p">)</span>
        <span class="n">st_s</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">scaled_sts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">st_s</span><span class="p">)</span>
        <span class="c1"># print st_s.rprimd</span>

    <span class="c1"># plt.plot([np.linalg.norm(st.rprimd) for st in scaled_sts])</span>
    <span class="c1"># plt.show()</span>
    <span class="c1"># sys.exit()</span>


    <span class="k">return</span> <span class="n">scaled_sts</span></div>




<div class="viewcode-block" id="find_moving_atom"><a class="viewcode-back" href="../../siman.html#siman.geo.find_moving_atom">[docs]</a><span class="k">def</span> <span class="nf">find_moving_atom</span><span class="p">(</span><span class="n">st1</span><span class="p">,</span> <span class="n">st2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    find moving atom</span>

<span class="sd">    The cells should have the same rprimd!</span>



<span class="sd">    return number of atom which moves between two cell</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">st1</span><span class="o">.</span><span class="n">rprimd</span><span class="p">,</span> <span class="n">st2</span><span class="o">.</span><span class="n">rprimd</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">r1</span><span class="o">-</span><span class="n">r2</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">0.001</span><span class="p">:</span>
            <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Attention! find_moving_atom(): st1 and st2 have different rprimd&#39;</span><span class="p">)</span>

    <span class="n">st1</span> <span class="o">=</span> <span class="n">st1</span><span class="o">.</span><span class="n">return_atoms_to_cell</span><span class="p">()</span>
    <span class="n">st2</span> <span class="o">=</span> <span class="n">st2</span><span class="o">.</span><span class="n">return_atoms_to_cell</span><span class="p">()</span>

    <span class="c1"># diffv = np.array(st1.xcart) - np.array(st2.xcart)</span>
    <span class="c1"># diffn = np.linalg.norm(diffv, axis = 1)</span>
    <span class="c1"># st1.write_poscar()</span>
    <span class="c1"># st2.write_poscar()</span>

    <span class="n">diffn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">st1</span><span class="o">.</span><span class="n">xcart</span><span class="p">,</span> <span class="n">st2</span><span class="o">.</span><span class="n">xcart</span><span class="p">):</span>
        <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">image_distance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">st1</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)</span>
        <span class="n">diffn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span>

    <span class="c1"># print(&#39;max&#39;, max(diffn))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">diffn</span><span class="p">)</span> <span class="c1"># number of atom moving along the path</span></div>







<div class="viewcode-block" id="calc_recip_vectors"><a class="viewcode-back" href="../../siman.html#siman.geo.calc_recip_vectors">[docs]</a><span class="k">def</span> <span class="nf">calc_recip_vectors</span><span class="p">(</span><span class="n">rprimd</span><span class="p">):</span>
    <span class="c1">#Determine reciprocal vectors </span>
    <span class="c1">#physics&quot; definition</span>
    <span class="n">recip</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">rprimd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">rprimd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rprimd</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>  <span class="p">);</span> <span class="c1">#volume</span>
    <span class="c1">#print vol</span>
    <span class="n">recip</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>   <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span> <span class="n">rprimd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rprimd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span>   <span class="p">)</span>
    <span class="n">recip</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>   <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span> <span class="n">rprimd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">rprimd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>   <span class="p">)</span>
    <span class="n">recip</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>   <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span> <span class="n">rprimd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rprimd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>   <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">recip</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>  <span class="n">recip</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">vol</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">recip</span></div>



<div class="viewcode-block" id="calc_kspacings"><a class="viewcode-back" href="../../siman.html#siman.geo.calc_kspacings">[docs]</a><span class="k">def</span> <span class="nf">calc_kspacings</span><span class="p">(</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">rprimd</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate kspacing from ngkpt and rprimd (A)</span>
<span class="sd">        ngkpt (list of int) - k-point mesh</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kspacing</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">recip</span> <span class="o">=</span> <span class="n">calc_recip_vectors</span><span class="p">(</span><span class="n">rprimd</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span> <span class="n">recip</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="n">ngkpt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">kspacing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">red_prec</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

    <span class="k">return</span>  <span class="n">kspacing</span></div>





<div class="viewcode-block" id="xcart2xred"><a class="viewcode-back" href="../../siman.html#siman.geo.xcart2xred">[docs]</a><span class="k">def</span> <span class="nf">xcart2xred</span><span class="p">(</span><span class="n">xcart</span><span class="p">,</span> <span class="n">rprimd</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert from cartesian coordinates xcart to</span>
<span class="sd">        dimensionless reduced coordinates </span>
<span class="sd">        Input: xcart - list of numpy arrays, rprimd - list of numpy arrays</span>
<span class="sd">        Output: xred - list of numpy arrays&quot;&quot;&quot;</span>
    <span class="n">xred</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">gprimd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">rprimd</span><span class="p">)</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">T</span> <span class="p">)</span> <span class="c1">#Transpose of the inverse matrix of rprimd</span>
    <span class="c1">#print gprimd</span>
    <span class="k">for</span> <span class="n">xc</span> <span class="ow">in</span> <span class="n">xcart</span><span class="p">:</span>
        <span class="n">xred</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>  <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">gprimd</span> <span class="p">,</span> <span class="n">xc</span><span class="p">)</span>  <span class="p">)</span> <span class="c1">#dot product</span>
    <span class="c1">#print xred</span>
    <span class="k">return</span> <span class="n">xred</span></div>

<div class="viewcode-block" id="xred2xcart"><a class="viewcode-back" href="../../siman.html#siman.geo.xred2xcart">[docs]</a><span class="k">def</span> <span class="nf">xred2xcart</span><span class="p">(</span><span class="n">xred</span><span class="p">,</span> <span class="n">rprimd</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert from dimensionless reduced coordinates to</span>
<span class="sd">    cartesian coordinates xcart;</span>
<span class="sd">        Input: xred - list of numpy arrays, rprimd - list of numpy arrays</span>
<span class="sd">        Output: xcart - list of numpy arrays&quot;&quot;&quot;</span>
    <span class="n">xcart</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#print &quot;rprimd &quot;, rprimd</span>
    <span class="k">for</span> <span class="n">xr</span> <span class="ow">in</span> <span class="n">xred</span><span class="p">:</span>
        <span class="c1">#for j in 0,1,2:</span>
        <span class="c1">#    print xr[0] * rprimd[0][j] + xr[1] * rprimd[1][j] + xr[2] * rprimd[2][j],</span>
        <span class="c1">#print &quot;&quot;</span>
        <span class="c1">#print np.dot( xr, rprimd)</span>
        <span class="n">xcart</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>  <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">xr</span><span class="p">,</span> <span class="n">rprimd</span><span class="p">)</span>  <span class="p">)</span> <span class="c1">#dot product</span>

    <span class="c1">#print xred</span>
    <span class="k">return</span> <span class="n">xcart</span></div>





<div class="viewcode-block" id="replic"><a class="viewcode-back" href="../../siman.html#siman.geo.replic">[docs]</a><span class="k">def</span> <span class="nf">replic</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">mul</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">inv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">only_atoms</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cut_one_cell</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">include_boundary</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replicate structure() according to: mul[i]*rprimd[i]</span>
<span class="sd">    </span>
<span class="sd">    Input:</span>
<span class="sd">    structure - structure() type</span>
<span class="sd">    mul[] - is tuple of three integer numbers</span>
<span class="sd">    Use from structure:</span>
<span class="sd">    xcart, typat, rprimd, natom, xred</span>
<span class="sd">    inv - 1 or -1 allows to replicate in different directions</span>
<span class="sd">    </span>
<span class="sd">    inv = 0 - cell is replicated in both directions by mul[i];  2 still gives -1 0 1 but 3 gives -2 -1 0 1 2; for &#39;only_matrix&#39; may work not correctly</span>


<span class="sd">    only_atoms - allows to replicate only specific atoms; now </span>
<span class="sd">        &#39;only_matrix&#39;</span>
<span class="sd">            Warning - st.select is not working here</span>

<span class="sd">    cut_one_cell - allows to cut only one cell with replicated edge atoms</span>
<span class="sd">    include_boundary (A) - the width of region to include additional edge atoms (bottom, up)</span>


<span class="sd">    Return:</span>
<span class="sd">    replicated structure</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
    <span class="c1"># print &#39;Structure has before replication&#39;, st.natom,&#39;atoms&#39; </span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="s1">&#39;init_numbers&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">st</span><span class="o">.</span><span class="n">init_numbers</span><span class="p">:</span>
        <span class="n">numbers</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">init_numbers</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">numbers</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">natom</span><span class="p">)</span>


    <span class="c1">#determine maximum and minimum values before replication</span>
    <span class="n">xmax</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1000000</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span>
    <span class="n">xmin</span> <span class="o">=</span> <span class="p">[</span><span class="o">+</span><span class="mi">1000000</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">st</span><span class="o">.</span><span class="n">xcart</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">xmax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span> <span class="n">xmax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> 
            <span class="k">if</span> <span class="n">xmin</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span> <span class="n">xmin</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> 
    <span class="c1"># print &#39;xmax, xmin&#39;, xmax, xmin</span>



    <span class="n">inv_loc</span> <span class="o">=</span> <span class="n">inv</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span>
        
        <span class="n">axis_mul</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">mul</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">inv</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># does not work propely; mul below is also should be accounted</span>
            <span class="n">axis_mul</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">mul</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">mul</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;axis_mul = &#39;</span><span class="p">,</span> <span class="n">axis_mul</span><span class="p">)</span>
            <span class="n">inv_loc</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="k">if</span> <span class="n">only_atoms</span> <span class="o">==</span> <span class="s1">&#39;only_matrix&#39;</span><span class="p">:</span>
            <span class="n">st</span><span class="o">.</span><span class="n">xcart</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">x</span> <span class="o">+</span> <span class="n">inv_loc</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">xcart</span><span class="p">[:],</span> <span class="n">st</span><span class="o">.</span><span class="n">typat</span><span class="p">[:])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">axis_mul</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="c1"># fill by axis i by blocks</span>
            
            <span class="n">st</span><span class="o">.</span><span class="n">typat</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">t</span>                  <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">st</span><span class="o">.</span><span class="n">typat</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">axis_mul</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">st</span><span class="o">.</span><span class="n">magmom</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">t</span>                  <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">st</span><span class="o">.</span><span class="n">magmom</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">axis_mul</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">st</span><span class="o">.</span><span class="n">xcart</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span> <span class="o">+</span> <span class="n">inv_loc</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">st</span><span class="o">.</span><span class="n">xcart</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">axis_mul</span> <span class="p">]</span> <span class="c1"># fill by axis i by blocks</span>
            <span class="n">st</span><span class="o">.</span><span class="n">typat</span> <span class="o">=</span> <span class="p">[</span> <span class="n">t</span>                  <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">st</span><span class="o">.</span><span class="n">typat</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">axis_mul</span> <span class="p">]</span>
            <span class="n">st</span><span class="o">.</span><span class="n">magmom</span> <span class="o">=</span> <span class="p">[</span> <span class="n">t</span>                  <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">st</span><span class="o">.</span><span class="n">magmom</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">axis_mul</span> <span class="p">]</span>
            <span class="n">st</span><span class="o">.</span><span class="n">select</span> <span class="o">=</span> <span class="p">[</span> <span class="n">t</span>                  <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">st</span><span class="o">.</span><span class="n">select</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">axis_mul</span> <span class="p">]</span>
            <span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">axis_mul</span><span class="p">]</span>
            <span class="c1"># print numbers</span>
            <span class="c1"># assert len(st.xcart) == abs(st.natom * reduce(lambda x, y: x*y, mul) )</span>


        <span class="c1"># print &#39;before&#39;, st.rprimd[i]</span>
        
    <span class="k">if</span> <span class="n">cut_one_cell</span><span class="p">:</span>
        <span class="k">pass</span>        
    <span class="k">else</span><span class="p">:</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inv</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mul</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">mul</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span>
        

    <span class="n">st</span><span class="o">.</span><span class="n">init_numbers</span> <span class="o">=</span> <span class="n">numbers</span>

        <span class="c1"># print st.init_numbers </span>
        <span class="c1"># print &#39;after&#39;, st.rprimd[i]</span>
    <span class="c1"># print len(st.xcart)</span>
    <span class="c1"># print st.natom * reduce(lambda x, y: x*y, mul)</span>
    <span class="c1">#print st.xcart, </span>

    <span class="n">st</span><span class="o">.</span><span class="n">xred</span> <span class="o">=</span> <span class="n">xcart2xred</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">xcart</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">cut_one_cell</span><span class="p">:</span>
        <span class="n">new_xred</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_xcart</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_typat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_mgmom</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">precb</span> <span class="o">=</span> <span class="n">include_boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="c1">#/max(st.rprimd[2])</span>
        <span class="n">precu</span> <span class="o">=</span> <span class="n">include_boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="c1">#/max(st.rprimd[2])</span>
        


        <span class="n">bob</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">precb</span><span class="p">;</span> <span class="n">upb</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">+</span> <span class="n">precu</span><span class="p">;</span>
        <span class="c1"># print bob, upb</span>
        

        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> 
        <span class="c1"># print st.xred</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span>  <span class="nb">zip</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">typat</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">xcart</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">magmom</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">xr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>  <span class="o">&lt;</span> <span class="n">xmin</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">precb</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">xr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>  <span class="o">&gt;</span> <span class="n">xmax</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">precu</span><span class="p">):</span> <span class="k">break</span>  
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_xcart</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xr</span><span class="p">)</span>
                <span class="n">new_typat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">new_magmom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="n">st</span><span class="o">.</span><span class="n">typat</span> <span class="o">=</span> <span class="n">new_typat</span>
        <span class="n">st</span><span class="o">.</span><span class="n">xcart</span> <span class="o">=</span> <span class="n">new_xcart</span>
        <span class="n">st</span><span class="o">.</span><span class="n">magmom</span> <span class="o">=</span> <span class="n">new_magmom</span>
        <span class="n">print_and_log</span><span class="p">(</span><span class="s1">&#39;After removing, cell has &#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">xred</span><span class="p">)</span> <span class="p">)</span>
        <span class="c1"># print st.xred</span>
        <span class="c1"># st.xcart = xred2xcart(st.xred, st.rprimd)</span>
        <span class="n">st</span><span class="o">.</span><span class="n">xred</span> <span class="o">=</span> <span class="n">xcart2xred</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">xcart</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)</span>

    <span class="n">st</span><span class="o">.</span><span class="n">get_nznucl</span><span class="p">()</span>
    <span class="n">st</span><span class="o">.</span><span class="n">natom</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">xcart</span><span class="p">)</span>
    <span class="c1"># print &#39;Structure is replicated; now&#39;, st.natom,&#39;atoms&#39; </span>
    <span class="k">return</span> <span class="n">st</span></div>



<div class="viewcode-block" id="local_surrounding"><a class="viewcode-back" href="../../siman.html#siman.geo.local_surrounding">[docs]</a><span class="k">def</span> <span class="nf">local_surrounding</span><span class="p">(</span><span class="n">x_central</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">n_neighbours</span><span class="p">,</span> <span class="n">control</span> <span class="o">=</span> <span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="n">periodic</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">only_elements</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">only_numbers</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">round_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return list of distances to n closest atoms around central atom. (By defauld sum of distances)</span>
<span class="sd">    </span>
<span class="sd">    Input:</span>
<span class="sd">    - x_central - cartesian coordinates of central atom; vector</span>
<span class="sd">    - st - structure with xcart list of coordinates of all atoms in system</span>
<span class="sd">    - n_neighbours - number of needed closest neighbours</span>

<span class="sd">    - control - type of output; </span>
<span class="sd">              sum - sum of distances, </span>
<span class="sd">              av - average distance, </span>
<span class="sd">              avsq - average squared dist</span>
<span class="sd">              &#39;mavm&#39;: #min, av, max, av excluding min and max</span>
<span class="sd">              av_dev - return (average deviation, maximum deviation) from average distance in mA.</span>
<span class="sd">              list - list of distances; </span>
<span class="sd">              atoms  - coordinates of neighbours</span>

<span class="sd">    - periodic - if True, then cell is additionaly replicated; needed for small cells</span>
<span class="sd">    Only for control = atoms</span>
<span class="sd">        - *only_elements* - list of z of elements to which only the distances are needed; </span>
<span class="sd">        - only_numbers  (list of int) - calc dist only to this atoms </span>

<span class="sd">    round_flag (bool) - if 1 than reduce distance prec to 2 points</span>


<span class="sd">    #TODO:</span>
<span class="sd">    the periodic boundary conditions realized very stupid by replicating the cell!</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># round_orig = round</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">round_flag</span><span class="p">:</span>
        <span class="c1"># overwrite round function with wrapper that do nothing</span>
        <span class="k">def</span> <span class="nf">my_round</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">my_round</span> <span class="o">=</span> <span class="nb">round</span>


    <span class="k">def</span> <span class="nf">av_dev</span><span class="p">(</span><span class="n">n_neighbours</span><span class="p">):</span>
        <span class="c1"># nonlocal n_neighbours</span>
        <span class="n">n_neighbours</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_neighbours</span><span class="p">)</span>
        <span class="n">dav</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dlistnn</span><span class="p">)</span><span class="o">/</span><span class="n">n_neighbours</span>
        <span class="n">av_dev</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="n">dav</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dlistnn</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="n">n_neighbours</span>
        <span class="n">max_dev</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="n">dav</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dlistnn</span><span class="p">])</span>
        
            
        <span class="k">return</span> <span class="n">my_round</span><span class="p">(</span><span class="n">av_dev</span><span class="o">*</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">my_round</span><span class="p">(</span><span class="n">max_dev</span><span class="o">*</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">st_original</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
    <span class="n">st</span><span class="o">.</span><span class="n">init_numbers</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">periodic</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">replic</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">mul</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">inv</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">)</span> <span class="c1"># to be sure that impurity is surrounded by atoms</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">replic</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">mul</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">inv</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>

    <span class="n">xcart</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">xcart</span>
    <span class="n">typat</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">typat</span>
    <span class="n">natom</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">natom</span>
    <span class="c1"># print x_central</span>

    <span class="c1">#print len(xcart)</span>
    <span class="k">if</span> <span class="n">only_elements</span><span class="p">:</span>
        <span class="n">only_elements</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">only_elements</span><span class="p">))</span>
        <span class="c1"># print(only_elements)</span>
        <span class="c1"># sys.exit()</span>


    <span class="n">zlist</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">znucl</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">st</span><span class="o">.</span><span class="n">typat</span><span class="p">]</span>
    

    <span class="n">dlist_unsort</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x_central</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xcart</span> <span class="p">]</span><span class="c1"># if all (x != x_central)] # list of all distances</span>

    <span class="k">if</span> <span class="n">only_elements</span><span class="p">:</span>
        <span class="n">dlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x_central</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xcart</span><span class="p">,</span> <span class="n">zlist</span><span class="p">)</span> <span class="k">if</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">only_elements</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dlist</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dlist_unsort</span><span class="p">)</span>
    <span class="n">dlist</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="c1"># print(&#39;local_surrounding(): dlist&#39;, dlist)</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dlist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dlist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">:</span>
        <span class="n">dlistnn</span> <span class="o">=</span> <span class="n">dlist</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n_neighbours</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#without first impurity which is x_central</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dlistnn</span> <span class="o">=</span> <span class="n">dlist</span><span class="p">[:</span><span class="n">n_neighbours</span><span class="p">]</span>

    <span class="c1"># print(&#39;dlistnn&#39;, dlistnn)</span>
    <span class="c1"># os._exit(1)</span>

    <span class="k">if</span> <span class="n">control</span> <span class="o">==</span> <span class="s1">&#39;list&#39;</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">dlistnn</span>

    <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span>
        
        <span class="n">output</span> <span class="o">=</span> <span class="n">my_round</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">dlistnn</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="s1">&#39;av&#39;</span><span class="p">:</span>
        <span class="n">n_neighbours</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_neighbours</span><span class="p">)</span>
        <span class="n">dav</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dlistnn</span><span class="p">)</span><span class="o">/</span><span class="n">n_neighbours</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">my_round</span><span class="p">(</span><span class="n">dav</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="s1">&#39;avsq&#39;</span><span class="p">:</span>
        <span class="n">n_neighbours</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_neighbours</span><span class="p">)</span>
        <span class="c1"># print(dlistnn)</span>
        <span class="n">davsq</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">d</span><span class="o">*</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dlistnn</span><span class="p">])</span><span class="o">/</span><span class="n">n_neighbours</span>
        <span class="n">davsq</span> <span class="o">=</span> <span class="n">davsq</span><span class="o">**</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">my_round</span><span class="p">(</span><span class="n">davsq</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>


    <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="s1">&#39;mavm&#39;</span><span class="p">:</span> <span class="c1">#min, av, max</span>
        <span class="n">dsort</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dlistnn</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_neighbours</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">my_round</span><span class="p">(</span><span class="n">dsort</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dsort</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">n_neighbours</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">my_round</span><span class="p">(</span><span class="n">dsort</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="p">)</span> <span class="c1">#min, av excluding min and max, max</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">my_round</span><span class="p">(</span><span class="n">dsort</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">my_round</span><span class="p">(</span><span class="n">dsort</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="p">)</span> <span class="c1">#min, av excluding min and max, max</span>

       
    <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="s1">&#39;av_dev&#39;</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">av_dev</span><span class="p">(</span><span class="n">n_neighbours</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="s1">&#39;sum_av_dev&#39;</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">my_round</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">dlistnn</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="n">av_dev</span><span class="p">(</span><span class="n">n_neighbours</span><span class="p">))</span>



    <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="s1">&#39;atoms&#39;</span><span class="p">:</span>
        <span class="c1"># print dlist_unsort</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="s1">&#39;init_numbers&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">st</span><span class="o">.</span><span class="n">init_numbers</span><span class="p">:</span>
            <span class="n">numbers</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">init_numbers</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numbers</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">natom</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dlist_unsort</span><span class="p">,</span> <span class="n">xcart</span><span class="p">,</span> <span class="n">typat</span><span class="p">,</span> <span class="n">numbers</span><span class="p">,</span> <span class="n">zlist</span><span class="p">)</span> <span class="p">)</span>
        
        <span class="n">temp</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>


        <span class="k">if</span> <span class="n">only_elements</span><span class="p">:</span>
            <span class="n">centr_type</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">centr_type</span> <span class="ow">in</span> <span class="n">only_elements</span><span class="p">:</span>
                <span class="n">first</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">first</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">first</span><span class="o">+</span><span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">temp</span> <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="ow">in</span> <span class="n">only_elements</span><span class="p">]</span> <span class="c1">#including central; included ionce even if only elements are and central are the same</span>

        <span class="k">if</span> <span class="n">only_numbers</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">temp</span> <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="ow">in</span> <span class="n">only_numbers</span><span class="p">]</span>



        <span class="n">temp2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">temp</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">dlist</span>       <span class="o">=</span> <span class="n">temp2</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="n">n_neighbours</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">xcart_local</span> <span class="o">=</span> <span class="n">temp2</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="n">n_neighbours</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">typat_local</span> <span class="o">=</span> <span class="n">temp2</span><span class="p">[</span><span class="mi">2</span><span class="p">][:</span><span class="n">n_neighbours</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">numbers</span>     <span class="o">=</span> <span class="n">temp2</span><span class="p">[</span><span class="mi">3</span><span class="p">][:</span><span class="n">n_neighbours</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># print temp2[0][:n_neighbours]</span>
        <span class="c1"># print xcart_local[:n_neighbours]</span>
        






        <span class="c1">#check if atoms in output are from neighboring cells</span>
        <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">xred_local</span> <span class="o">=</span> <span class="n">xcart2xred</span><span class="p">(</span><span class="n">xcart_local</span><span class="p">,</span> <span class="n">st_original</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)</span>
            <span class="c1"># print &#39;xred_local&#39;, xred_local</span>
            <span class="k">for</span> <span class="n">x_l</span> <span class="ow">in</span> <span class="n">xred_local</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x_l</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> 
                        <span class="n">x_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-=</span><span class="mi">1</span>
                        <span class="c1"># print &#39;returning to prim cell&#39;, x,x_l[i]</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> 
                        <span class="n">x_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                        <span class="c1"># print &#39;returning to prim cell&#39;, x,x_l[i]</span>
            <span class="n">xcart_local</span> <span class="o">=</span> <span class="n">xred2xcart</span><span class="p">(</span><span class="n">xred_local</span><span class="p">,</span> <span class="n">st_original</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)</span>

        <span class="c1"># print &#39;Warning! local_surrounding() can return several atoms in one position due to incomplete PBC implementation; Improve please\n&#39;</span>

        <span class="n">output</span> <span class="o">=</span>  <span class="p">(</span><span class="n">xcart_local</span><span class="p">,</span> <span class="n">typat_local</span><span class="p">,</span> <span class="n">numbers</span><span class="p">,</span> <span class="n">dlist</span> <span class="p">)</span>

    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="local_surrounding2"><a class="viewcode-back" href="../../siman.html#siman.geo.local_surrounding2">[docs]</a><span class="k">def</span> <span class="nf">local_surrounding2</span><span class="p">(</span><span class="n">x_central</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">n_neighbours</span><span class="p">,</span> <span class="n">control</span> <span class="o">=</span> <span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="n">periodic</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">only_elements</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">only_numbers</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">round_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    !!! Attempt to improve speed of periodic conditions!</span>
<span class="sd">    #control = &#39;atoms&#39; could work wrong!!! check</span>

<span class="sd">    Return list of distances to n closest atoms around central atom. (By defauld sum of distances)</span>
<span class="sd">    </span>
<span class="sd">    Input:</span>
<span class="sd">    - x_central - cartesian coordinates of central atom; vector</span>
<span class="sd">    - st - structure with xcart list of coordinates of all atoms in system</span>
<span class="sd">    - n_neighbours - number of needed closest neighbours</span>

<span class="sd">    - control - type of output; </span>
<span class="sd">              sum - sum of distances, </span>
<span class="sd">              av - average distance, </span>
<span class="sd">              avsq - average squared dist</span>
<span class="sd">              &#39;mavm&#39;: #min, av, max, av excluding min and max</span>
<span class="sd">              av_dev - return (average deviation, maximum deviation) from average distance in mA.</span>
<span class="sd">              list - list of distances; </span>
<span class="sd">              atoms  - coordinates of neighbours</span>

<span class="sd">    - periodic - if True, then cell is additionaly replicated; needed for small cells</span>
<span class="sd">    Only for control = atoms</span>
<span class="sd">        - *only_elements* - list of z of elements to which only the distances are needed; </span>
<span class="sd">        - only_numbers  (list of int) - calc dist only to this atoms </span>

<span class="sd">    round_flag (bool) - if 1 than reduce distance prec to 2 points</span>


<span class="sd">    #TODO:</span>
<span class="sd">    the periodic boundary conditions realized very stupid by replicating the cell!</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># round_orig = round</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">round_flag</span><span class="p">:</span>
        <span class="c1"># overwrite round function with wrapper that do nothing</span>
        <span class="k">def</span> <span class="nf">my_round</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">my_round</span> <span class="o">=</span> <span class="nb">round</span>


    <span class="k">def</span> <span class="nf">av_dev</span><span class="p">(</span><span class="n">n_neighbours</span><span class="p">):</span>
        <span class="c1"># nonlocal n_neighbours</span>
        <span class="n">n_neighbours</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_neighbours</span><span class="p">)</span>
        <span class="n">dav</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dlistnn</span><span class="p">)</span><span class="o">/</span><span class="n">n_neighbours</span>
        <span class="n">av_dev</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="n">dav</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dlistnn</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="n">n_neighbours</span>
        <span class="n">max_dev</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="n">dav</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dlistnn</span><span class="p">])</span>
        
            
        <span class="k">return</span> <span class="n">my_round</span><span class="p">(</span><span class="n">av_dev</span><span class="o">*</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">my_round</span><span class="p">(</span><span class="n">max_dev</span><span class="o">*</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">st_original</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
    <span class="n">st</span><span class="o">.</span><span class="n">init_numbers</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">periodic</span><span class="p">:</span>
        <span class="s1">&#39;&#39;</span>
        <span class="c1"># not needed anymore, since image_distance is used,</span>
        <span class="c1"># however for &#39;atoms&#39; regime more actions can be needed</span>
        <span class="c1"># st = replic(st, mul = (2,2,2), inv = 1 ) # to be sure that impurity is surrounded by atoms</span>
        <span class="c1"># st = replic(st, mul = (2,2,2), inv = -1 )</span>

    <span class="n">xcart</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">xcart</span>
    <span class="n">typat</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">typat</span>
    <span class="n">natom</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">natom</span>
    <span class="c1"># print x_central</span>

    <span class="c1">#print len(xcart)</span>
    <span class="k">if</span> <span class="n">only_elements</span><span class="p">:</span>
        <span class="n">only_elements</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">only_elements</span><span class="p">))</span>
        <span class="c1"># print(only_elements)</span>
        <span class="c1"># sys.exit()</span>


    <span class="n">zlist</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">znucl</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">st</span><span class="o">.</span><span class="n">typat</span><span class="p">]</span>
    

    <span class="n">dlist_unsort</span> <span class="o">=</span> <span class="p">[</span><span class="n">image_distance</span><span class="p">(</span><span class="n">x_central</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xcart</span> <span class="p">]</span><span class="c1"># if all (x != x_central)] # list of all distances</span>

    <span class="k">if</span> <span class="n">only_elements</span><span class="p">:</span>
        <span class="n">dlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">image_distance</span><span class="p">(</span><span class="n">x_central</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xcart</span><span class="p">,</span> <span class="n">zlist</span><span class="p">)</span> <span class="k">if</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">only_elements</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dlist</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dlist_unsort</span><span class="p">)</span>
    <span class="n">dlist</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="c1"># print(&#39;local_surrounding(): dlist&#39;, dlist)</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dlist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dlist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">:</span>
        <span class="n">dlistnn</span> <span class="o">=</span> <span class="n">dlist</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n_neighbours</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#without first impurity which is x_central</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dlistnn</span> <span class="o">=</span> <span class="n">dlist</span><span class="p">[:</span><span class="n">n_neighbours</span><span class="p">]</span>

    <span class="c1"># print(&#39;dlistnn&#39;, dlistnn)</span>
    <span class="c1"># os._exit(1)</span>

    <span class="k">if</span> <span class="n">control</span> <span class="o">==</span> <span class="s1">&#39;list&#39;</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">dlistnn</span>

    <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span>
        
        <span class="n">output</span> <span class="o">=</span> <span class="n">my_round</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">dlistnn</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="s1">&#39;av&#39;</span><span class="p">:</span>
        <span class="n">n_neighbours</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_neighbours</span><span class="p">)</span>
        <span class="n">dav</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dlistnn</span><span class="p">)</span><span class="o">/</span><span class="n">n_neighbours</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">my_round</span><span class="p">(</span><span class="n">dav</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="s1">&#39;avsq&#39;</span><span class="p">:</span>
        <span class="n">n_neighbours</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_neighbours</span><span class="p">)</span>
        <span class="c1"># print(dlistnn)</span>
        <span class="n">davsq</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">d</span><span class="o">*</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dlistnn</span><span class="p">])</span><span class="o">/</span><span class="n">n_neighbours</span>
        <span class="n">davsq</span> <span class="o">=</span> <span class="n">davsq</span><span class="o">**</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">my_round</span><span class="p">(</span><span class="n">davsq</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>


    <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="s1">&#39;mavm&#39;</span><span class="p">:</span> <span class="c1">#min, av, max</span>
        <span class="n">dsort</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dlistnn</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_neighbours</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">my_round</span><span class="p">(</span><span class="n">dsort</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dsort</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">n_neighbours</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">my_round</span><span class="p">(</span><span class="n">dsort</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="p">)</span> <span class="c1">#min, av excluding min and max, max</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">my_round</span><span class="p">(</span><span class="n">dsort</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">my_round</span><span class="p">(</span><span class="n">dsort</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="p">)</span> <span class="c1">#min, av excluding min and max, max</span>

       
    <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="s1">&#39;av_dev&#39;</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">av_dev</span><span class="p">(</span><span class="n">n_neighbours</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="s1">&#39;sum_av_dev&#39;</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">my_round</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">dlistnn</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="n">av_dev</span><span class="p">(</span><span class="n">n_neighbours</span><span class="p">))</span>



    <span class="k">elif</span> <span class="n">control</span> <span class="o">==</span> <span class="s1">&#39;atoms&#39;</span><span class="p">:</span>
        <span class="c1"># print dlist_unsort</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="s1">&#39;init_numbers&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">st</span><span class="o">.</span><span class="n">init_numbers</span><span class="p">:</span>
            <span class="n">numbers</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">init_numbers</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numbers</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">natom</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dlist_unsort</span><span class="p">,</span> <span class="n">xcart</span><span class="p">,</span> <span class="n">typat</span><span class="p">,</span> <span class="n">numbers</span><span class="p">,</span> <span class="n">zlist</span><span class="p">)</span> <span class="p">)</span>
        
        <span class="n">temp</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>


        <span class="k">if</span> <span class="n">only_elements</span><span class="p">:</span>
            <span class="n">centr_type</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">centr_type</span> <span class="ow">in</span> <span class="n">only_elements</span><span class="p">:</span>
                <span class="n">first</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">first</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">first</span><span class="o">+</span><span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">temp</span> <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="ow">in</span> <span class="n">only_elements</span><span class="p">]</span> <span class="c1">#including central; included ionce even if only elements are and central are the same</span>

        <span class="k">if</span> <span class="n">only_numbers</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">temp</span> <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="ow">in</span> <span class="n">only_numbers</span><span class="p">]</span>



        <span class="n">temp2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">temp</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">dlist</span>       <span class="o">=</span> <span class="n">temp2</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="n">n_neighbours</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">xcart_local</span> <span class="o">=</span> <span class="n">temp2</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="n">n_neighbours</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">typat_local</span> <span class="o">=</span> <span class="n">temp2</span><span class="p">[</span><span class="mi">2</span><span class="p">][:</span><span class="n">n_neighbours</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">numbers</span>     <span class="o">=</span> <span class="n">temp2</span><span class="p">[</span><span class="mi">3</span><span class="p">][:</span><span class="n">n_neighbours</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># print temp2[0][:n_neighbours]</span>
        <span class="c1"># print xcart_local[:n_neighbours]</span>
        






        <span class="c1">#check if atoms in output are from neighboring cells</span>
        <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">xred_local</span> <span class="o">=</span> <span class="n">xcart2xred</span><span class="p">(</span><span class="n">xcart_local</span><span class="p">,</span> <span class="n">st_original</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)</span>
            <span class="c1"># print &#39;xred_local&#39;, xred_local</span>
            <span class="k">for</span> <span class="n">x_l</span> <span class="ow">in</span> <span class="n">xred_local</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x_l</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> 
                        <span class="n">x_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-=</span><span class="mi">1</span>
                        <span class="c1"># print &#39;returning to prim cell&#39;, x,x_l[i]</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> 
                        <span class="n">x_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
                        <span class="c1"># print &#39;returning to prim cell&#39;, x,x_l[i]</span>
            <span class="n">xcart_local</span> <span class="o">=</span> <span class="n">xred2xcart</span><span class="p">(</span><span class="n">xred_local</span><span class="p">,</span> <span class="n">st_original</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)</span>

        <span class="c1"># print &#39;Warning! local_surrounding() can return several atoms in one position due to incomplete PBC implementation; Improve please\n&#39;</span>

        <span class="n">output</span> <span class="o">=</span>  <span class="p">(</span><span class="n">xcart_local</span><span class="p">,</span> <span class="n">typat_local</span><span class="p">,</span> <span class="n">numbers</span><span class="p">,</span> <span class="n">dlist</span> <span class="p">)</span>

    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="ortho_vec_old"><a class="viewcode-back" href="../../siman.html#siman.geo.ortho_vec_old">[docs]</a><span class="k">def</span> <span class="nf">ortho_vec_old</span><span class="p">(</span><span class="n">rprim</span><span class="p">,</span> <span class="n">ortho_sizes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    old function</span>
<span class="sd">    Function returns mul_mat - 3 vectors of integer numbers (ndarray)</span>
<span class="sd">    By calculating np.dot(mul_matrix, st.rprimd) you will get rprim of orthogonal supercell (actually as close as possible to it) </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">savelyev</span> <span class="k">import</span> <span class="n">vector_i</span> 

    <span class="n">a</span> <span class="o">=</span> <span class="n">vector_i</span><span class="o">.</span><span class="n">Vector</span><span class="p">()</span>
    <span class="n">a</span><span class="o">.</span><span class="n">vec_new_in_vec_old</span><span class="p">(</span><span class="n">vec_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">ortho_sizes</span><span class="p">),</span> <span class="n">vec_old</span> <span class="o">=</span> <span class="n">rprim</span><span class="p">)</span>
    <span class="n">mul_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">vec_new_in_old</span><span class="p">)</span>
    <span class="n">mul_matrix</span> <span class="o">=</span> <span class="n">mul_matrix</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">mul_matrix</span> <span class="o">=</span> <span class="n">mul_matrix</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">mul_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mul_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">mul_matrix</span></div>

<div class="viewcode-block" id="ortho_vec"><a class="viewcode-back" href="../../siman.html#siman.geo.ortho_vec">[docs]</a><span class="k">def</span> <span class="nf">ortho_vec</span><span class="p">(</span><span class="n">rprim</span><span class="p">,</span> <span class="n">ortho_sizes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function returns mul_mat - 3 vectors of integer numbers (ndarray)</span>
<span class="sd">    By calculating np.dot(mul_matrix, rprim) you will get rprim of orthogonal supercell (actually as close as possible to it) </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Calculating mul_matrix for ortho:&#39;</span><span class="p">,</span><span class="n">ortho_sizes</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">,)</span>
    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;rprim is;&#39;</span><span class="p">,</span> <span class="n">rprim</span><span class="p">)</span>
    <span class="n">vec_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">ortho_sizes</span><span class="p">)</span>

    <span class="c1"># print(rprim)</span>
    <span class="c1"># t = rprim[1]</span>
    <span class="c1"># rprim[1] = rprim[0]</span>
    <span class="c1"># rprim[0] = t</span>


    <span class="n">mul_matrix_float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">vec_new</span><span class="p">,</span>  <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">rprim</span><span class="p">)</span> <span class="p">)</span>

    <span class="c1"># ortho_test = np.dot(mul_matrix_float, rprim )</span>

    <span class="c1"># print(ortho_test)</span>
    <span class="c1"># print(mul_matrix_float)</span>
    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;mul_matrix_float:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">mul_matrix_float</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">mul_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mul_matrix_float</span><span class="p">)</span>
    <span class="n">mul_matrix</span> <span class="o">=</span> <span class="n">mul_matrix</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">mul_matrix</span> <span class="o">=</span> <span class="n">mul_matrix</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>


    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">mul_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># mul_matrix[i][i] = 1</span>
            <span class="s1">&#39;&#39;</span>

    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;mul_matrix:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">mul_matrix</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>


    <span class="k">return</span> <span class="n">mul_matrix</span></div>

<span class="c1"># def mul_matrix(rprimd1, rprimd2):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Determines mul matrix needed to obtain rprimd2 from rprimd1</span>
<span class="c1">#     &quot;&quot;&quot;</span>




<div class="viewcode-block" id="create_supercell"><a class="viewcode-back" href="../../siman.html#siman.geo.create_supercell">[docs]</a><span class="k">def</span> <span class="nf">create_supercell</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">mul_matrix</span><span class="p">,</span> <span class="n">test_overlap</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">mp</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">bound</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    st (Structure) -  </span>
<span class="sd">    mul_matrix (3x3 ndarray of int) - for example created by *ortho_    vec()* </span>


<span class="sd">    bound (float) - shift (A) allows to correctly account atoms on boundaries</span>
<span class="sd">    mp    (int)  include additionall atoms before cutting supecell</span>
<span class="sd">    test_overlap (bool) - check if atoms are overlapping -  quite slow</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    <span class="n">sc</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">new</span><span class="p">()</span> 
    <span class="c1"># st = st.return_atoms_to_cell()</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39;_supercell&#39;</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">rprimd</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mul_matrix</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">rprimd</span>  <span class="p">))</span>
    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Old vectors (rprimd):</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1"># printlog(&#39;Mul_matrix:\n&#39;,mul_matrix, imp = &#39;y&#39;, end = &#39;\n&#39;)</span>

    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;New vectors (rprimd) of supercell:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">rprimd</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">sc</span><span class="o">.</span><span class="n">rprimd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">rprimd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sc</span><span class="o">.</span><span class="n">rprimd</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>  <span class="p">)</span>
    <span class="n">st</span><span class="o">.</span><span class="n">vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>  <span class="p">)</span>
    <span class="c1"># sc_natom_i = int(sc.vol/st.vol*st.natom) # test</span>
    <span class="c1"># print(st.natom)</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="s1">&#39;magmom&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">typat</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">magmom</span><span class="p">):</span>
            <span class="n">st</span><span class="o">.</span><span class="n">magmom</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">st</span><span class="o">.</span><span class="n">natom</span>
            <span class="n">mag_flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mag_flag</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">st</span><span class="o">.</span><span class="n">magmom</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">st</span><span class="o">.</span><span class="n">natom</span>
        <span class="n">mag_flag</span> <span class="o">=</span> <span class="kc">False</span>        

    <span class="n">sc_natom</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">vol</span><span class="o">/</span><span class="n">st</span><span class="o">.</span><span class="n">vol</span><span class="o">*</span><span class="n">st</span><span class="o">.</span><span class="n">natom</span> <span class="c1"># test</span>
    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;The supercell should contain&#39;</span><span class="p">,</span> <span class="n">sc_natom</span><span class="p">,</span> <span class="s1">&#39;atoms ... </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">xcart</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">typat</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">xred</span>  <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">magmom</span>  <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#find range of multiplication</span>
    <span class="n">mi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mul_matrix</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">ma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">mul_matrix</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">mi</span><span class="p">[</span><span class="n">mi</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># </span>

    <span class="c1"># print(mi, ma)</span>




    <span class="c1"># find bound values</span>
    <span class="n">lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">rprimd</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="n">bound</span><span class="o">/</span><span class="n">lengths</span> <span class="c1"># in reduced coordinates</span>
    <span class="c1"># print(bounds)</span>
    <span class="c1"># print(st.xcart)</span>
    <span class="c1"># print([range(*z) for z in zip(mi-mp, ma+mp)])</span>
    <span class="c1"># print(st.rprimd)</span>
    <span class="c1"># print(sc.rprimd)</span>
    <span class="k">for</span> <span class="n">uvw</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mi</span><span class="o">-</span><span class="n">mp</span><span class="p">,</span> <span class="n">ma</span><span class="o">+</span><span class="n">mp</span><span class="p">)]):</span> <span class="c1">#loop over all ness uvw</span>
        <span class="c1"># print(uvw)</span>
        <span class="n">xcart_mul</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">xcart</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">uvw</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)</span> <span class="c1"># coordinates of basis for each uvw</span>
        <span class="c1"># print(xcart_mul)</span>
        <span class="n">xred_mul</span>  <span class="o">=</span> <span class="n">xcart2xred</span><span class="p">(</span><span class="n">xcart_mul</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)</span>

        <span class="c1"># print(len(xred_mul), len(xcart_mul), len(st.typat), len(st.magmom) )</span>
        <span class="k">for</span> <span class="n">xr</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span>  <span class="n">t</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xred_mul</span><span class="p">,</span> <span class="n">xcart_mul</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">typat</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">magmom</span><span class="p">):</span>
            <span class="c1"># if 0&lt;xr[0]&lt;1 and 0&lt;xr[1]&lt;1 and 0&lt;xr[2]&lt;1:</span>
                <span class="c1"># print (xr)</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="n">b</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">-</span><span class="n">b</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xr</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)]):</span> <span class="c1">#only that in sc.rprimd box are needed</span>
                <span class="n">sc</span><span class="o">.</span><span class="n">xcart</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">xc</span> <span class="p">)</span>
                <span class="n">sc</span><span class="o">.</span><span class="n">xred</span><span class="o">.</span><span class="n">append</span> <span class="p">(</span> <span class="n">xr</span> <span class="p">)</span>
                <span class="n">sc</span><span class="o">.</span><span class="n">typat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">t</span>  <span class="p">)</span>
                <span class="n">sc</span><span class="o">.</span><span class="n">magmom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    

    <span class="n">sc</span><span class="o">.</span><span class="n">natom</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">xcart</span><span class="p">)</span>


    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">natom</span> <span class="o">-</span> <span class="n">sc_natom</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">1e-5</span><span class="p">:</span> <span class="c1">#test 1, number of atoms</span>
        <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Error! Supercell contains wrong number of atoms:&#39;</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">natom</span>  <span class="p">,</span> <span class="s1">&#39;instead of&#39;</span><span class="p">,</span> <span class="n">sc_natom</span><span class="p">,</span> 
            <span class="s1">&#39;try to increase *mp* of change *bound* &#39;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">test_overlap</span><span class="p">:</span> <span class="c1">#test 2: overlapping of atoms</span>
        <span class="n">enx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">xcart</span><span class="p">))</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="p">(</span><span class="n">i2</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">enx</span><span class="p">,</span> <span class="n">enx</span><span class="p">):</span>
            <span class="c1"># print image_distance(x1, x2, sc.rprimd)[0]</span>
            <span class="k">if</span> <span class="n">i1</span> <span class="o">!=</span> <span class="n">i2</span> <span class="ow">and</span> <span class="n">image_distance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">:</span> <span class="c1">#less than 0.1 Angstrom</span>
                <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Error! Atoms in supercell are overlapping. Play with *bound*&#39;</span><span class="p">)</span>

    <span class="n">sc</span><span class="o">.</span><span class="n">recip</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_recip</span><span class="p">()</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">znucl</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">znucl</span><span class="p">)</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">ntypat</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">ntypat</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">nznucl</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get_nznucl</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">mag_flag</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">magmom</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>


    <span class="k">return</span> <span class="n">sc</span></div>


<div class="viewcode-block" id="supercell"><a class="viewcode-back" href="../../siman.html#siman.geo.supercell">[docs]</a><span class="k">def</span> <span class="nf">supercell</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">ortho_sizes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    wrapper</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mul_matrix</span> <span class="o">=</span> <span class="n">ortho_vec</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">,</span> <span class="n">ortho_sizes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">create_supercell</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">mul_matrix</span><span class="p">)</span></div>

<div class="viewcode-block" id="cubic_supercell"><a class="viewcode-back" href="../../siman.html#siman.geo.cubic_supercell">[docs]</a><span class="k">def</span> <span class="nf">cubic_supercell</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">ortho_sizes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    wrapper</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mul_matrix</span> <span class="o">=</span> <span class="n">ortho_vec</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">,</span> <span class="n">ortho_sizes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">create_supercell</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">mul_matrix</span><span class="p">)</span></div>


<div class="viewcode-block" id="determine_symmetry_positions"><a class="viewcode-back" href="../../siman.html#siman.geo.determine_symmetry_positions">[docs]</a><span class="k">def</span> <span class="nf">determine_symmetry_positions</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">silent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    determine non-equivalent positions for atoms of type *element*</span>

<span class="sd">    element (str) - name of element, for example Li</span>

<span class="sd">    return list of lists -  atom numbers for each non-equivalent position</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">pymatgen.symmetry.analyzer</span> <span class="k">import</span> <span class="n">SpacegroupAnalyzer</span>


    <span class="n">stp</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">convert2pymatgen</span><span class="p">()</span>

    <span class="n">spg</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">stp</span><span class="p">)</span>

    <span class="n">info</span> <span class="o">=</span> <span class="n">spg</span><span class="o">.</span><span class="n">get_symmetry_dataset</span><span class="p">()</span>

    <span class="n">positions</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">get_elements</span><span class="p">(),</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;equivalent_atoms&#39;</span><span class="p">])):</span>
        
        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="n">element</span> <span class="ow">and</span> <span class="n">pos</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">:</span>
            <span class="n">positions</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">el</span> <span class="o">==</span> <span class="n">element</span><span class="p">:</span>
            <span class="n">positions</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
        <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;I have found &#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span> <span class="s1">&#39;non-equivalent positions for&#39;</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span><span class="n">positions</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">positions_for_print</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">:</span>
        <span class="n">positions_for_print</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
        <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Atom numbers: &#39;</span><span class="p">,</span> <span class="n">positions_for_print</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
    
    <span class="n">sorted_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">positions</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="n">pos_lists</span> <span class="o">=</span> <span class="p">[</span><span class="n">positions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sorted_keys</span> <span class="p">]</span>

    <span class="k">return</span> <span class="n">pos_lists</span></div>



<div class="viewcode-block" id="remove_atoms"><a class="viewcode-back" href="../../siman.html#siman.geo.remove_atoms">[docs]</a><span class="k">def</span> <span class="nf">remove_atoms</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">atoms_to_remove</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    remove atoms either of types provided in *atoms_to_remove* or having numbers provided in *atoms_to_remove*</span>
<span class="sd">    st (Structure)</span>
<span class="sd">    atoms_to_remove (list) - list of element names or numbers</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">remove_atoms</span><span class="p">(</span><span class="n">atoms_to_remove</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">st</span></div>


<div class="viewcode-block" id="remove_one_atom"><a class="viewcode-back" href="../../siman.html#siman.geo.remove_one_atom">[docs]</a><span class="k">def</span> <span class="nf">remove_one_atom</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">del_pos</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">iat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    removes one atom of element type from position del_pos</span>
<span class="sd">    iat - number of atom inside subset</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># if not del_pos:</span>
    <span class="c1">#     del_pos = 1</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="n">determine_symmetry_positions</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">del_pos</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Error! More than one symmetry position is found, please choose del position starting from 1&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">del_pos</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Position&#39;</span><span class="p">,</span> <span class="n">del_pos</span><span class="p">,</span> <span class="s1">&#39;was chosen&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>

    <span class="n">pos</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span> <span class="n">del_pos</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">]</span>
    <span class="n">i_del</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">iat</span><span class="p">]</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">del_atom</span><span class="p">(</span><span class="n">i_del</span><span class="p">)</span> <span class="c1"># remove just iat atom</span>
    <span class="n">st</span><span class="o">.</span><span class="n">name</span> <span class="o">+=</span> <span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">element</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i_del</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;del&#39;</span>
    <span class="n">st</span><span class="o">.</span><span class="n">magmom</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">st</span><span class="p">,</span> <span class="n">i_del</span></div>

<div class="viewcode-block" id="create_deintercalated_structure"><a class="viewcode-back" href="../../siman.html#siman.geo.create_deintercalated_structure">[docs]</a><span class="k">def</span> <span class="nf">create_deintercalated_structure</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">del_pos</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns deintercalated structures</span>

<span class="sd">    del_pos(int) - number of position starting from 1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="n">determine_symmetry_positions</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
    <span class="c1"># position_list = sorted(list(positions.keys()))</span>
    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Choose from the following list using *del_pos*:&#39;</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
        <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;     &#39;</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;---&gt;&#39;</span> <span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>

    <span class="c1"># pos = position_list[ del_pos - 1 ]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span> <span class="n">del_pos</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">]</span>

    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;You have chosen position:&#39;</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>

    <span class="c1"># print(st.get_elements())</span>

    <span class="n">st1</span> <span class="o">=</span> <span class="n">remove_atoms</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">atoms_to_remove</span> <span class="o">=</span> <span class="n">pos</span><span class="p">)</span>
    <span class="n">st1</span><span class="o">.</span><span class="n">name</span> <span class="o">+=</span> <span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">element</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;del&#39;</span>
    <span class="c1"># print(st1.get_elements())</span>
    <span class="c1"># sys.exit()</span>

    <span class="k">return</span> <span class="n">st1</span></div>


<div class="viewcode-block" id="create_replaced_structure"><a class="viewcode-back" href="../../siman.html#siman.geo.create_replaced_structure">[docs]</a><span class="k">def</span> <span class="nf">create_replaced_structure</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">el1</span><span class="p">,</span> <span class="n">el2</span><span class="p">,</span> <span class="n">rep_pos</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">only_one</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    allow to replace symmetry non-equivalent positions structures</span>

<span class="sd">    rep_pos(int) - number of position starting from 1</span>
<span class="sd">    only_one - replace only one first atom</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="n">determine_symmetry_positions</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">el1</span><span class="p">)</span>
    <span class="c1"># position_list = sorted(list(positions.keys()))</span>
    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Choose from the following list using *del_pos*:&#39;</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
        <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;     &#39;</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;---&gt;&#39;</span> <span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>

    <span class="c1"># pos = position_list[ del_pos - 1 ]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span> <span class="n">rep_pos</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">]</span>

    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;You have chosen position:&#39;</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>

    <span class="c1"># print(st.get_elements())</span>
    <span class="k">if</span> <span class="n">only_one</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>


    <span class="n">st1</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">replace_atoms</span><span class="p">(</span><span class="n">atoms_to_replace</span> <span class="o">=</span> <span class="n">pos</span><span class="p">,</span> <span class="n">el_new</span> <span class="o">=</span> <span class="n">el2</span><span class="p">)</span>
    <span class="n">st1</span><span class="o">.</span><span class="n">name</span> <span class="o">+=</span> <span class="s1">&#39;.&#39;</span><span class="o">+</span><span class="n">el1</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span><span class="o">+</span><span class="n">el2</span><span class="o">+</span><span class="s1">&#39;rep&#39;</span>
    <span class="c1"># print(st1.get_elements())</span>
    <span class="c1"># sys.exit()</span>

    <span class="k">return</span> <span class="n">st1</span></div>








<div class="viewcode-block" id="create_antisite_defect_old"><a class="viewcode-back" href="../../siman.html#siman.geo.create_antisite_defect_old">[docs]</a><span class="k">def</span> <span class="nf">create_antisite_defect_old</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">cation_positions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    exchange cation and transition metal</span>
<span class="sd">    st (Structure)</span>

<span class="sd">    cation_positions (list of numpy arrays) - reduced coordinates of deintercalated cation positions</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#1. Find first alkali ion</span>
    <span class="k">def</span> <span class="nf">find_alkali_ion</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">j_need</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># return the number of found alk ion of *j_need* occurrence </span>
        <span class="n">elements</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">get_elements_z</span><span class="p">()</span>
        <span class="c1"># print (elements)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">header</span><span class="o">.</span><span class="n">ALKALI_ION_ELEMENTS</span><span class="p">:</span>
                <span class="c1"># print (i,el)</span>
                <span class="n">j</span><span class="o">+=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">j_need</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">i</span>



    <span class="n">i_alk</span> <span class="o">=</span> <span class="n">find_alkali_ion</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">x_alk</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">xcart</span><span class="p">[</span><span class="n">i_alk</span><span class="p">]</span>


    <span class="c1">#2. Find closest transition metal</span>
    <span class="n">sur</span> <span class="o">=</span> <span class="n">local_surrounding</span><span class="p">(</span><span class="n">x_alk</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">n_neighbours</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> 
        <span class="n">control</span> <span class="o">=</span> <span class="s1">&#39;atoms&#39;</span><span class="p">,</span> <span class="n">only_elements</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">TRANSITION_ELEMENTS</span><span class="p">,</span> <span class="n">periodic</span>  <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

    <span class="n">i_tr</span> <span class="o">=</span> <span class="n">sur</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x_tr</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">xcart</span><span class="p">[</span><span class="n">i_tr</span><span class="p">]</span>


    
    <span class="c1">#3. Swap atoms</span>
    <span class="n">st</span><span class="o">.</span><span class="n">write_xyz</span><span class="p">(</span><span class="n">file_name</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39;_antisite_start&#39;</span><span class="p">)</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">mov_atoms</span><span class="p">(</span><span class="n">i_alk</span><span class="p">,</span> <span class="n">x_tr</span><span class="p">)</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">mov_atoms</span><span class="p">(</span><span class="n">i_tr</span><span class="p">,</span>  <span class="n">x_alk</span><span class="p">)</span>

    <span class="n">st</span><span class="o">.</span><span class="n">write_xyz</span><span class="p">(</span><span class="n">file_name</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39;_antisite_final&#39;</span><span class="p">)</span>

    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Atom &#39;</span><span class="p">,</span><span class="n">i_alk</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="n">i_tr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;were swapped&#39;</span><span class="p">)</span>
    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;The distance between them is &#39;</span><span class="p">,</span> <span class="n">sur</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">st</span><span class="o">.</span><span class="n">magmom</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">st</span></div>



<div class="viewcode-block" id="create_antisite_defect2"><a class="viewcode-back" href="../../siman.html#siman.geo.create_antisite_defect2">[docs]</a><span class="k">def</span> <span class="nf">create_antisite_defect2</span><span class="p">(</span><span class="n">st_base</span><span class="p">,</span> <span class="n">st_from</span><span class="p">,</span> <span class="n">cation</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">trans</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">trans_pos</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="n">mode</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    exchange cation and transition metal</span>
<span class="sd">    st_base (Structure) - basic structure in which defects are created</span>
<span class="sd">    st_from (Structure) - structure from which the positions of *cation* are chosen;  st_from should be consistent with st_base </span>
<span class="sd">    cation (str) - element, position of which is extracted from st_from and added to st_base</span>

<span class="sd">    trans (str) - element name transition metal for exchange</span>
<span class="sd">    trans_pos (int) - number of non-equiv position of trans starting from 1</span>

<span class="sd">    mode - </span>
<span class="sd">        &#39;add_alk&#39; or &#39;a1&#39; - add alkali cation</span>
<span class="sd">        &#39;mov_trs&#39; or &#39;a2&#39; - mov trans to alkali pos</span>
<span class="sd">        &#39;add_swp&#39; or &#39;a3&#39; - add alk and swap with trans</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;create_antisite_defect2(): mode = &#39;</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>


    <span class="n">st</span> <span class="o">=</span> <span class="n">st_base</span>

    <span class="n">cation_xred</span> <span class="o">=</span> <span class="n">st_from</span><span class="o">.</span><span class="n">get_element_xred</span><span class="p">(</span><span class="n">cation</span><span class="p">)</span>
    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;For cation &#39;</span><span class="p">,</span> <span class="n">cation</span><span class="p">,</span> <span class="s1">&#39;reduced coordinates:&#39;</span><span class="p">,</span><span class="n">cation_xred</span><span class="p">,</span> <span class="s1">&#39; were chosen&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>


    <span class="n">positions</span> <span class="o">=</span> <span class="n">determine_symmetry_positions</span><span class="p">(</span><span class="n">st_from</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Transition atom &#39;</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="s1">&#39;has &#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span> <span class="s1">&#39;non-equiv positions&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
    <span class="n">transition_numbers</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">trans_pos</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>



    <span class="c1">#1. Insert cation</span>
    <span class="n">cation_xcart</span> <span class="o">=</span> <span class="n">xred2xcart</span><span class="p">([</span><span class="n">cation_xred</span><span class="p">],</span> <span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">st_i</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">add_atoms</span><span class="p">([</span><span class="n">cation_xcart</span><span class="p">],</span> <span class="n">cation</span><span class="p">)</span>
    <span class="n">st_i</span><span class="o">.</span><span class="n">write_xyz</span><span class="p">(</span><span class="n">filename</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">cation</span><span class="o">+</span><span class="s1">&#39;_added&#39;</span><span class="p">)</span>


    <span class="c1">#2. Find transition metal atoms close to cation_xcart and move it here</span>
    <span class="n">sur</span> <span class="o">=</span> <span class="n">local_surrounding</span><span class="p">(</span><span class="n">cation_xcart</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">n_neighbours</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> 
        <span class="n">control</span> <span class="o">=</span> <span class="s1">&#39;atoms&#39;</span><span class="p">,</span> <span class="n">only_numbers</span> <span class="o">=</span> <span class="n">transition_numbers</span><span class="p">,</span> <span class="n">periodic</span>  <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

    <span class="n">i_trans</span> <span class="o">=</span> <span class="n">sur</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x_trans</span> <span class="o">=</span> <span class="n">sur</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">st_m</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">mov_atoms</span><span class="p">(</span><span class="n">sur</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">cation_xcart</span><span class="p">)</span>
    <span class="n">st_m</span><span class="o">.</span><span class="n">write_xyz</span><span class="p">(</span><span class="n">filename</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39;_trans_moved&#39;</span><span class="p">)</span>


    <span class="c1">#3. Put cation to empty trans metal pos</span>
    <span class="n">st_s</span> <span class="o">=</span> <span class="n">st_m</span><span class="o">.</span><span class="n">add_atoms</span><span class="p">([</span><span class="n">x_trans</span><span class="p">],</span> <span class="n">cation</span><span class="p">)</span>
    <span class="n">st_s</span><span class="o">.</span><span class="n">write_xyz</span><span class="p">(</span><span class="n">filename</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39;_swapped&#39;</span><span class="p">)</span>


    <span class="k">if</span> <span class="s1">&#39;add_alk&#39;</span> <span class="ow">in</span> <span class="n">mode</span> <span class="ow">or</span> <span class="s1">&#39;a1&#39;</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st_i</span>
    <span class="k">elif</span> <span class="s1">&#39;mov_trs&#39;</span> <span class="ow">in</span> <span class="n">mode</span> <span class="ow">or</span> <span class="s1">&#39;a2&#39;</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st_m</span>
    <span class="k">elif</span> <span class="s1">&#39;add_swp&#39;</span> <span class="ow">in</span> <span class="n">mode</span> <span class="ow">or</span> <span class="s1">&#39;a3&#39;</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st_s</span>

    <span class="n">st</span><span class="o">.</span><span class="n">magmom</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">st</span></div>



<div class="viewcode-block" id="create_antisite_defect3"><a class="viewcode-back" href="../../siman.html#siman.geo.create_antisite_defect3">[docs]</a><span class="k">def</span> <span class="nf">create_antisite_defect3</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">el1</span><span class="p">,</span> <span class="n">el2</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">max_sep</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">iatom</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Looks for all unique antisites for el1 and el2</span>
<span class="sd">    </span>
<span class="sd">    iatom (int) - create antistes only using this atom number</span>

<span class="sd">    Todo</span>
<span class="sd">    #check that distances through  PBC are two small</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># tol = 0.1 #tolerance for distinguishing antisites within one group</span>
    <span class="c1"># max_sep = 4 # maximum separation of antisite</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">rprimd</span>
    <span class="n">pos1</span> <span class="o">=</span> <span class="n">determine_symmetry_positions</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">el1</span><span class="p">)</span>
    <span class="n">pos2</span> <span class="o">=</span> <span class="n">determine_symmetry_positions</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">el2</span><span class="p">)</span>

    <span class="n">anti</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">eqv_atoms1</span> <span class="ow">in</span> <span class="n">pos1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">eqv_atoms2</span> <span class="ow">in</span> <span class="n">pos2</span><span class="p">:</span>
            <span class="n">uniq1</span> <span class="o">=</span> <span class="n">eqv_atoms1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">uniq2</span> <span class="o">=</span> <span class="n">eqv_atoms2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lab</span> <span class="o">=</span> <span class="p">(</span><span class="n">uniq1</span><span class="p">,</span> <span class="n">uniq2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lab</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">anti</span><span class="p">:</span>
                <span class="n">anti</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">at1</span> <span class="ow">in</span> <span class="n">eqv_atoms1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">at2</span> <span class="ow">in</span> <span class="n">eqv_atoms2</span><span class="p">:</span>

                    <span class="k">if</span> <span class="n">iatom</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">at1</span> <span class="o">!=</span> <span class="n">iatom</span><span class="p">:</span>
                            <span class="k">continue</span>

                    <span class="n">x1</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">xcart</span><span class="p">[</span><span class="n">at1</span><span class="p">]</span>
                    <span class="n">x2</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">xcart</span><span class="p">[</span><span class="n">at2</span><span class="p">]</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">image_distance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">r</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    
                    <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">max_sep</span><span class="p">:</span>
                        <span class="k">continue</span> <span class="c1"># skip larger than asked</span>

                    <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">anti</span><span class="p">[</span><span class="n">lab</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="n">tup</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>  <span class="c1">#antisite already included </span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">anti</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">at1</span><span class="p">,</span> <span class="n">at2</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
                        <span class="c1"># print(lab, at1, at2, d)</span>
    
    <span class="n">structures</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">table</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">anti</span><span class="p">:</span>
        <span class="n">anti</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="c1"># print([k]+anti[k])</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">anti</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
            <span class="n">table</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
            <span class="c1"># st_as = copy.deepcopy(st)</span>
            <span class="n">st_as</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">swap_atoms</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">suf</span> <span class="o">=</span> <span class="s1">&#39;as&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># st_as.name+=&#39;_as_&#39;+str(k)+&#39;_with_atoms_&#39;+str(a[0]+1)+&#39;_and_&#39;+str(a[1]+1)+&#39;_swapped&#39;</span>
            <span class="n">st_as</span><span class="o">.</span><span class="n">name</span><span class="o">+=</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">suf</span>
            <span class="n">st_as</span><span class="o">.</span><span class="n">magmom</span> <span class="o">=</span> <span class="kc">None</span>
            
            <span class="n">st_as</span><span class="o">.</span><span class="n">i_el1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">st_as</span><span class="o">.</span><span class="n">i_el2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>             

            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>

            <span class="n">structures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">st_as</span><span class="p">)</span>
            <span class="n">st_as</span><span class="o">.</span><span class="n">write_poscar</span><span class="p">()</span>
    <span class="n">st</span><span class="o">.</span><span class="n">write_xyz</span><span class="p">()</span>

    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;List of antisites:&#39;</span><span class="p">,</span> <span class="n">imp</span>  <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>

    <span class="n">printlog</span><span class="p">(</span> <span class="n">tabulate</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;No.&#39;</span><span class="p">,</span> <span class="s1">&#39;Antisite type&#39;</span><span class="p">,</span> <span class="s1">&#39;at1&#39;</span><span class="p">,</span> <span class="s1">&#39;at2&#39;</span><span class="p">,</span> <span class="s1">&#39;Separation, A&#39;</span><span class="p">],</span> <span class="n">tablefmt</span><span class="o">=</span><span class="s1">&#39;psql&#39;</span><span class="p">),</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;Y&#39;</span> <span class="p">)</span>



    <span class="k">return</span> <span class="n">structures</span></div>



<span class="n">create_antisite_defect</span> <span class="o">=</span> <span class="n">create_antisite_defect3</span>


<div class="viewcode-block" id="calc_k_point_mesh"><a class="viewcode-back" href="../../siman.html#siman.geo.calc_k_point_mesh">[docs]</a><span class="k">def</span> <span class="nf">calc_k_point_mesh</span><span class="p">(</span><span class="n">rprimd</span><span class="p">,</span> <span class="n">kspacing</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    rprimd (list of lists 3x3 of floats) - vectors of cell (Angstroms)</span>
<span class="sd">    kspacing (float) - required spacing between k-points in reciprocal space (A-1); paramter KSPACING in VASP</span>

<span class="sd">    the provided optimal k-mesh has the smallest sum of squared deviations of kspacings</span>

<span class="sd">    returns k-point mesh (list of int)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">recip</span> <span class="o">=</span> <span class="n">calc_recip_vectors</span><span class="p">(</span><span class="n">rprimd</span><span class="p">)</span>
    <span class="c1"># print(recip)</span>


    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">recip</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">/</span> <span class="n">kspacing</span>
        <span class="n">N</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>

    <span class="n">N_options</span> <span class="o">=</span> <span class="p">[</span><span class="n">ng</span> <span class="k">for</span> <span class="n">ng</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span> <span class="o">*</span><span class="p">[(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">N</span><span class="p">]</span> <span class="p">)</span> <span class="p">]</span>

    <span class="n">errors</span> <span class="o">=</span> <span class="p">[</span>  <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">calc_kspacings</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">rprimd</span><span class="p">)</span> <span class="p">)</span> <span class="o">-</span> <span class="n">kspacing</span> <span class="p">)</span> <span class="p">)</span> <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="n">N_options</span><span class="p">]</span> <span class="c1"># sum of squared deviation from kspacing for each option</span>
    <span class="n">i_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>

    <span class="n">N_opt</span> <span class="o">=</span> <span class="n">N_options</span><span class="p">[</span><span class="n">i_min</span><span class="p">]</span> <span class="c1"># k-mesh with smallest error</span>



    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;I recommend k-point mesh:&#39;</span><span class="p">,</span> <span class="n">N_opt</span><span class="p">,</span> <span class="s1">&#39;with k-spacings:&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">calc_kspacings</span><span class="p">(</span><span class="n">N_opt</span><span class="p">,</span> <span class="n">rprimd</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span> <span class="p">)</span>
    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;Other options are:&#39;</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span> <span class="p">)</span>
    <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:13s}</span><span class="s1"> |    </span><span class="si">{:20s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Mesh&#39;</span><span class="p">,</span> <span class="s1">&#39;k-spacings&#39;</span><span class="p">),</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span>  <span class="p">)</span>

    <span class="k">for</span> <span class="n">ngkpt</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span> <span class="o">*</span><span class="p">[(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">N_opt</span><span class="p">]</span> <span class="p">):</span>
        
        <span class="n">printlog</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:13s}</span><span class="s1"> |    </span><span class="si">{:26s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ngkpt</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">calc_kspacings</span><span class="p">(</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">rprimd</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">))),</span> <span class="n">end</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span>  <span class="p">)</span>


    <span class="k">return</span> <span class="n">N_opt</span></div>






<div class="viewcode-block" id="remove_half_based_on_symmetry"><a class="viewcode-back" href="../../siman.html#siman.geo.remove_half_based_on_symmetry">[docs]</a><span class="k">def</span> <span class="nf">remove_half_based_on_symmetry</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">sg</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">info_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate all possible configurations by removing half of atoms</span>
<span class="sd">    sg (int) - give back structure with specific space group</span>

<span class="sd">    info_mode (bool) if 1 then return list of possible space groups</span>
<span class="sd">    </span>
<span class="sd">    return list of structures with sg space groups</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Counter</span>

    <span class="k">def</span> <span class="nf">spin</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find recursivly all possible orderings</span>
<span class="sd">        ls - initial list of atoms </span>
<span class="sd">        i - index in ls  </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            
            <span class="n">ls</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
            
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            
                <span class="n">spin</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">orderings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span> <span class="p">)</span>  
        <span class="k">return</span>


    <span class="n">structures</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">orderings</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ls</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">st</span><span class="o">.</span><span class="n">natom</span>
    <span class="n">spin</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">symmetries</span> <span class="o">=</span> <span class="p">[]</span>


    <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="n">orderings</span><span class="p">:</span>
        <span class="n">atoms_to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># print(atoms_to_remove)</span>
        <span class="n">st_rem</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">remove_atoms</span><span class="p">(</span><span class="n">atoms_to_remove</span><span class="p">)</span>
        <span class="n">nm</span> <span class="o">=</span> <span class="n">st_rem</span><span class="o">.</span><span class="n">sg</span><span class="p">(</span><span class="n">silent</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># if nm &gt; 50:</span>
            <span class="c1"># print(nm)</span>
        <span class="n">symmetries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nm</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">nm</span> <span class="o">==</span> <span class="n">sg</span><span class="p">:</span>
            <span class="c1"># st_rem.jmol()</span>
            <span class="c1"># sc = supercell(st_rem, [14,14,14])</span>
            <span class="c1"># sc.jmol()</span>
            <span class="c1"># sc.write_poscar(&#39;xyz/POSCAR_SC2_half&#39;)</span>
            <span class="c1"># sc.write_cif(&#39;xyz/POSCAR_SC2_half&#39;)</span>
            <span class="c1"># sys.exit()</span>
            <span class="n">structures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">st_rem</span><span class="p">)</span>

    <span class="c1"># print(len(orderings))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The following space groups were found&#39;</span><span class="p">,</span> <span class="n">Counter</span><span class="p">(</span><span class="n">symmetries</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">info_mode</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">symmetries</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">structures</span></div>







<div class="viewcode-block" id="remove_half"><a class="viewcode-back" href="../../siman.html#siman.geo.remove_half">[docs]</a><span class="k">def</span> <span class="nf">remove_half</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">sg</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">info_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # works only for </span>

<span class="sd">    sg - required space group</span>

<span class="sd">    TODO</span>
<span class="sd">    1. Take care about matching the initial cell and supercell from primitive</span>
<span class="sd">    Now the manual shift is done</span>

<span class="sd">    2. Make full conversion from pymat structure to mine</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">prim</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="kn">from</span> <span class="nn">pymatgen.symmetry.analyzer</span> <span class="k">import</span> <span class="n">SpacegroupAnalyzer</span>
    <span class="kn">from</span> <span class="nn">pymatgen.io.vasp.inputs</span> <span class="k">import</span> <span class="n">Poscar</span>
    <span class="kn">from</span> <span class="nn">calc_manage</span> <span class="k">import</span> <span class="n">smart_structure_read</span>
    <span class="n">st_ohne_el</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">remove_atoms</span><span class="p">([</span><span class="n">el</span><span class="p">])</span>



    <span class="n">st_only_el</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">leave_only</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>

    <span class="n">st_mp</span> <span class="o">=</span> <span class="n">st_only_el</span><span class="o">.</span><span class="n">convert2pymatgen</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">prim</span><span class="p">:</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">st_mp</span><span class="p">)</span>
        <span class="n">st_mp_prim</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">find_primitive</span><span class="p">()</span> <span class="c1"># find primitive based only on element el</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">st_mp_prim</span> <span class="o">=</span> <span class="n">st_mp</span>

    <span class="c1">#convert back to my format! please improve!!!</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Poscar</span><span class="p">(</span><span class="n">st_mp_prim</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">write_file</span><span class="p">(</span><span class="s1">&#39;xyz/POSCAR&#39;</span><span class="p">)</span>
    <span class="n">st_prim</span> <span class="o">=</span> <span class="n">smart_structure_read</span><span class="p">(</span><span class="s1">&#39;xyz/POSCAR&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">info_mode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">remove_half_based_on_symmetry</span><span class="p">(</span><span class="n">st_prim</span><span class="p">,</span> <span class="n">info_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">sts</span> <span class="o">=</span> <span class="n">remove_half_based_on_symmetry</span><span class="p">(</span><span class="n">st_prim</span><span class="p">,</span> <span class="n">sg</span><span class="p">)</span>




    <span class="n">st_only_el_half</span> <span class="o">=</span> <span class="n">sts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="c1"># now only first configuration is taken, they could be different</span>


    <span class="k">if</span> <span class="n">prim</span><span class="p">:</span>
        <span class="n">mul_matrix_float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">,</span>  <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">st_prim</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">mul_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mul_matrix_float</span><span class="p">)</span>
        <span class="n">mul_matrix</span> <span class="o">=</span> <span class="n">mul_matrix</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mul_matrix</span> <span class="o">=</span> <span class="n">mul_matrix</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>



        <span class="n">sc_only_el_half</span> <span class="o">=</span> <span class="n">create_supercell</span><span class="p">(</span><span class="n">st_only_el_half</span><span class="p">,</span> <span class="n">mul_matrix</span> <span class="o">=</span> <span class="n">mul_matrix</span><span class="p">)</span>

        <span class="n">sc_only_el_half</span> <span class="o">=</span> <span class="n">sc_only_el_half</span><span class="o">.</span><span class="n">shift_atoms</span><span class="p">([</span><span class="mf">0.125</span><span class="p">,</span><span class="mf">0.125</span><span class="p">,</span><span class="mf">0.125</span><span class="p">])</span>
        <span class="n">sc_only_el_half</span> <span class="o">=</span> <span class="n">sc_only_el_half</span><span class="o">.</span><span class="n">return_atoms_to_cell</span><span class="p">()</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">sc_only_el_half</span> <span class="o">=</span> <span class="n">st_only_el_half</span>
        <span class="c1"># sc_only_el_half</span>


    <span class="c1"># st_only_el.write_poscar(&#39;xyz/POSCAR1&#39;)</span>
    <span class="c1"># sc_only_el_half.write_poscar(&#39;xyz/POSCAR2&#39;)</span>


    <span class="n">st_half</span> <span class="o">=</span> <span class="n">st_ohne_el</span><span class="o">.</span><span class="n">add_atoms</span><span class="p">(</span><span class="n">sc_only_el_half</span><span class="o">.</span><span class="n">xcart</span><span class="p">,</span> <span class="n">el</span><span class="p">)</span>

    <span class="n">st_half</span><span class="o">.</span><span class="n">name</span><span class="o">+=</span><span class="s1">&#39;_half&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">st_half</span></div>




<div class="viewcode-block" id="remove_x_based_on_symmetry"><a class="viewcode-back" href="../../siman.html#siman.geo.remove_x_based_on_symmetry">[docs]</a><span class="k">def</span> <span class="nf">remove_x_based_on_symmetry</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">sg</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">info_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate all possible configurations by removing half of atoms</span>
<span class="sd">    sg (int) - give back structure with specific space group</span>

<span class="sd">    info_mode (bool) if 1 then return list of possible space groups</span>
<span class="sd">    </span>
<span class="sd">    return list of structures with sg space groups</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Counter</span>

    <span class="k">def</span> <span class="nf">spin</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find recursivly all possible orderings</span>
<span class="sd">        ls - initial list of atoms </span>
<span class="sd">        i - index in ls  </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            
            <span class="n">ls</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
            
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            
                <span class="n">spin</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ls</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">st</span><span class="o">.</span><span class="n">natom</span> <span class="o">-</span> <span class="n">x</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">:</span>
                    <span class="n">orderings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span> <span class="p">)</span>  
        <span class="k">return</span>


    <span class="n">structures</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">orderings</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ls</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">st</span><span class="o">.</span><span class="n">natom</span>
    <span class="n">spin</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">symmetries</span> <span class="o">=</span> <span class="p">[]</span>


    <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="n">orderings</span><span class="p">:</span>
        <span class="n">atoms_to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># print(atoms_to_remove)</span>
        <span class="n">st_rem</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">remove_atoms</span><span class="p">(</span><span class="n">atoms_to_remove</span><span class="p">)</span>
        <span class="n">nm</span> <span class="o">=</span> <span class="n">st_rem</span><span class="o">.</span><span class="n">sg</span><span class="p">(</span><span class="n">silent</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># if nm &gt; 50:</span>
            <span class="c1"># print(nm)</span>
        <span class="n">symmetries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nm</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">nm</span> <span class="o">==</span> <span class="n">sg</span><span class="p">:</span>
            <span class="c1"># st_rem.jmol()</span>
            <span class="c1"># sc = supercell(st_rem, [14,14,14])</span>
            <span class="c1"># sc.jmol()</span>
            <span class="c1"># sc.write_poscar(&#39;xyz/POSCAR_SC2_half&#39;)</span>
            <span class="c1"># sc.write_cif(&#39;xyz/POSCAR_SC2_half&#39;)</span>
            <span class="c1"># sys.exit()</span>
            <span class="n">structures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">st_rem</span><span class="p">)</span>

    <span class="c1"># print(len(orderings))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The following space groups were found&#39;</span><span class="p">,</span> <span class="n">Counter</span><span class="p">(</span><span class="n">symmetries</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">info_mode</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">symmetries</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">structures</span></div>



<div class="viewcode-block" id="remove_x"><a class="viewcode-back" href="../../siman.html#siman.geo.remove_x">[docs]</a><span class="k">def</span> <span class="nf">remove_x</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span> <span class="n">sg</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">info_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # works only for </span>
<span class="sd">    x - remove x of atoms, for example 0.25 of atoms</span>

<span class="sd">    sg - required space group</span>

<span class="sd">    TODO</span>
<span class="sd">    1. Take care about matching the initial cell and supercell from primitive</span>
<span class="sd">    Now the manual shift is done</span>

<span class="sd">    2. Make full conversion from pymat structure to mine</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">prim</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="kn">from</span> <span class="nn">pymatgen.symmetry.analyzer</span> <span class="k">import</span> <span class="n">SpacegroupAnalyzer</span>
    <span class="kn">from</span> <span class="nn">pymatgen.io.vasp.inputs</span> <span class="k">import</span> <span class="n">Poscar</span>
    <span class="kn">from</span> <span class="nn">calc_manage</span> <span class="k">import</span> <span class="n">smart_structure_read</span>
    <span class="n">st_ohne_el</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">remove_atoms</span><span class="p">([</span><span class="n">el</span><span class="p">])</span>



    <span class="n">st_only_el</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">leave_only</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>

    <span class="n">st_mp</span> <span class="o">=</span> <span class="n">st_only_el</span><span class="o">.</span><span class="n">convert2pymatgen</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">prim</span><span class="p">:</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">st_mp</span><span class="p">)</span>
        <span class="n">st_mp_prim</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">find_primitive</span><span class="p">()</span> <span class="c1"># find primitive based only on element el</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">st_mp_prim</span> <span class="o">=</span> <span class="n">st_mp</span>

    <span class="c1">#convert back to my format! please improve!!!</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Poscar</span><span class="p">(</span><span class="n">st_mp_prim</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">write_file</span><span class="p">(</span><span class="s1">&#39;xyz/POSCAR&#39;</span><span class="p">)</span>
    <span class="n">st_prim</span> <span class="o">=</span> <span class="n">smart_structure_read</span><span class="p">(</span><span class="s1">&#39;xyz/POSCAR&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">info_mode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">remove_x_based_on_symmetry</span><span class="p">(</span><span class="n">st_prim</span><span class="p">,</span> <span class="n">info_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">)</span>

    <span class="n">sts</span> <span class="o">=</span> <span class="n">remove_x_based_on_symmetry</span><span class="p">(</span><span class="n">st_prim</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="p">)</span>




    <span class="n">st_only_el_half</span> <span class="o">=</span> <span class="n">sts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   <span class="c1"># now only first configuration is taken, they could be different</span>


    <span class="k">if</span> <span class="n">prim</span><span class="p">:</span>
        <span class="n">mul_matrix_float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">,</span>  <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">st_prim</span><span class="o">.</span><span class="n">rprimd</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">mul_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mul_matrix_float</span><span class="p">)</span>
        <span class="n">mul_matrix</span> <span class="o">=</span> <span class="n">mul_matrix</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mul_matrix</span> <span class="o">=</span> <span class="n">mul_matrix</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>



        <span class="n">sc_only_el_half</span> <span class="o">=</span> <span class="n">create_supercell</span><span class="p">(</span><span class="n">st_only_el_half</span><span class="p">,</span> <span class="n">mul_matrix</span> <span class="o">=</span> <span class="n">mul_matrix</span><span class="p">)</span>

        <span class="n">sc_only_el_half</span> <span class="o">=</span> <span class="n">sc_only_el_half</span><span class="o">.</span><span class="n">shift_atoms</span><span class="p">([</span><span class="mf">0.125</span><span class="p">,</span><span class="mf">0.125</span><span class="p">,</span><span class="mf">0.125</span><span class="p">])</span>
        <span class="n">sc_only_el_half</span> <span class="o">=</span> <span class="n">sc_only_el_half</span><span class="o">.</span><span class="n">return_atoms_to_cell</span><span class="p">()</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">sc_only_el_half</span> <span class="o">=</span> <span class="n">st_only_el_half</span>
        <span class="c1"># sc_only_el_half</span>


    <span class="c1"># st_only_el.write_poscar(&#39;xyz/POSCAR1&#39;)</span>
    <span class="c1"># sc_only_el_half.write_poscar(&#39;xyz/POSCAR2&#39;)</span>


    <span class="n">st_half</span> <span class="o">=</span> <span class="n">st_ohne_el</span><span class="o">.</span><span class="n">add_atoms</span><span class="p">(</span><span class="n">sc_only_el_half</span><span class="o">.</span><span class="n">xcart</span><span class="p">,</span> <span class="n">el</span><span class="p">)</span>

    <span class="n">st_half</span><span class="o">.</span><span class="n">name</span><span class="o">+=</span><span class="s1">&#39;_half&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">st_half</span></div>
















<div class="viewcode-block" id="primitive"><a class="viewcode-back" href="../../siman.html#siman.geo.primitive">[docs]</a><span class="k">def</span> <span class="nf">primitive</span><span class="p">(</span><span class="n">st</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">pymatgen.symmetry.analyzer</span> <span class="k">import</span> <span class="n">SpacegroupAnalyzer</span>
    
    <span class="n">st</span><span class="o">.</span><span class="n">sg</span><span class="p">()</span>
    <span class="c1"># st.jmol()</span>
    <span class="n">st_mp</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">convert2pymatgen</span><span class="p">()</span>
    <span class="c1"># print(st_mp)</span>


    <span class="n">sf</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">st_mp</span><span class="p">)</span>

    <span class="n">st_mp_prim</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">find_primitive</span><span class="p">()</span>

    <span class="c1"># print(st_mp_prim)</span>

    <span class="n">st</span>  <span class="o">=</span><span class="n">st</span><span class="o">.</span><span class="n">update_from_pymatgen</span><span class="p">(</span><span class="n">st_mp_prim</span><span class="p">)</span>
    <span class="c1"># st.sg()</span>
    <span class="k">return</span> <span class="n">st</span></div>





<div class="viewcode-block" id="create_surface"><a class="viewcode-back" href="../../siman.html#siman.geo.create_surface">[docs]</a><span class="k">def</span> <span class="nf">create_surface</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">miller_index</span><span class="p">,</span> <span class="n">min_slab_size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">min_vacuum_size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">surface_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">oxidation</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    INPUT:</span>
<span class="sd">        st (Structure) - Initial input structure. Note that to</span>
<span class="sd">                ensure that the miller indices correspond to usual</span>
<span class="sd">                crystallographic definitions, you should supply a conventional</span>
<span class="sd">                unit cell structure.</span>

<span class="sd">        miller_index ([h, k, l]): Miller index of plane parallel to</span>
<span class="sd">                        surface. Note that this is referenced to the input structure. If</span>
<span class="sd">                        you need this to be based on the conventional cell,</span>
<span class="sd">                        you should supply the conventional structure.</span>


<span class="sd">        oxidation (dic) - dictionary of effective oxidation states, e. g. {&#39;Y&#39;:&#39;Y3+&#39;, &#39;Ba&#39;:&#39;Ba2+&#39;, &#39;Co&#39;:&#39;Co2.25+&#39;, &#39;O&#39;:&#39;O2-&#39;}</span>
<span class="sd">                          allows to calculate dipole moment</span>

<span class="sd">        surface_i (int) - choose particular surface </span>

<span class="sd">        min_slab_size (float) - minimum slab size</span>

<span class="sd">        min_vacuum_size (float) - vacuum thicknes in A</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">pymatgen.core.surface</span> <span class="k">import</span> <span class="n">SlabGenerator</span>
    <span class="kn">from</span> <span class="nn">pymatgen.io.vasp.inputs</span> <span class="k">import</span> <span class="n">Poscar</span>
    <span class="kn">from</span> <span class="nn">siman.geo</span> <span class="k">import</span> <span class="n">replic</span>


    <span class="n">pm</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">convert2pymatgen</span><span class="p">(</span><span class="n">oxidation</span> <span class="o">=</span> <span class="n">oxidation</span><span class="p">)</span>
    <span class="c1"># pm = st.convert2pymatgen()</span>


    <span class="n">slabgen</span> <span class="o">=</span> <span class="n">SlabGenerator</span><span class="p">(</span><span class="n">pm</span><span class="p">,</span> <span class="n">miller_index</span><span class="p">,</span> <span class="n">min_slab_size</span><span class="p">,</span> <span class="n">min_vacuum_size</span><span class="p">)</span>
    <span class="c1"># print(slabgen.oriented_unit_cell)</span>
    <span class="n">slabs</span> <span class="o">=</span> <span class="n">slabgen</span><span class="o">.</span><span class="n">get_slabs</span><span class="p">()</span>

    <span class="n">printlog</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">slabs</span><span class="p">),</span> <span class="s1">&#39;surfaces were generated, choose required surface using *surface_i* argument</span><span class="se">\n</span><span class="s1">Writing POSCARs to xyz&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">slab</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slabs</span><span class="p">):</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">Poscar</span><span class="p">(</span><span class="n">slab</span><span class="p">)</span>
        <span class="n">pos</span><span class="o">.</span><span class="n">write_file</span><span class="p">(</span><span class="s1">&#39;xyz/POSCAR_suf&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">slabs</span><span class="p">[</span><span class="n">surface_i</span><span class="p">]</span></div>



<div class="viewcode-block" id="create_surface2"><a class="viewcode-back" href="../../siman.html#siman.geo.create_surface2">[docs]</a><span class="k">def</span> <span class="nf">create_surface2</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">miller_index</span><span class="p">,</span> <span class="n">shift</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">min_slab_size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">min_vacuum_size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">surface_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">oxidation</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">suf</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> 
    <span class="n">primitive</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">symmetrize</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">cut_thickness</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">return_one</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">write_poscar</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    INPUT:</span>
<span class="sd">        st (Structure) - Initial input structure. Note that to</span>
<span class="sd">                ensure that the miller indices correspond to usual</span>
<span class="sd">                crystallographic definitions, you should supply a conventional</span>
<span class="sd">                unit cell structure.</span>


<span class="sd">        pymatgen-related:</span>
<span class="sd">            miller_index ([h, k, l]): Miller index of plane parallel to</span>
<span class="sd">                            surface. Note that this is referenced to the input structure. If</span>
<span class="sd">                            you need this to be based on the conventional cell,</span>
<span class="sd">                            you should supply the conventional structure.</span>


<span class="sd">            oxidation (dic) - dictionary of effective oxidation states, e. g. {&#39;Y&#39;:&#39;Y3+&#39;, &#39;Ba&#39;:&#39;Ba2+&#39;, &#39;Co&#39;:&#39;Co2.25+&#39;, &#39;O&#39;:&#39;O2-&#39;}</span>
<span class="sd">                              allows to calculate dipole moment</span>

<span class="sd">            surface_i (int) - choose particular surface </span>

<span class="sd">            min_slab_size (float) - minimum slab size</span>

<span class="sd">            min_vacuum_size (float) - vacuum thicknes in A</span>

<span class="sd">            symmetrize - try to make both surfaces exact</span>


<span class="sd">        my_paramters:</span>
<span class="sd">        shift (float) - shift along z </span>
<span class="sd">        cut_thickness (float) - in A - allow to remove more layers from top</span>
<span class="sd">        return_one (bool) - allows to return only one Structure, otherwise list of pymatgen slabs is returned </span>
<span class="sd">        write_poscar (bool) -self-explained</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">pymatgen.core.surface</span> <span class="k">import</span> <span class="n">SlabGenerator</span>
    <span class="kn">from</span> <span class="nn">pymatgen.io.vasp.inputs</span> <span class="k">import</span> <span class="n">Poscar</span>
    <span class="kn">from</span> <span class="nn">siman.geo</span> <span class="k">import</span> <span class="n">replic</span>

    <span class="k">if</span> <span class="n">shift</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">shift_atoms</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">shift</span><span class="p">])</span>

    <span class="n">pm</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">convert2pymatgen</span><span class="p">(</span><span class="n">oxidation</span> <span class="o">=</span> <span class="n">oxidation</span><span class="p">)</span>
    <span class="c1"># pm = st.convert2pymatgen()</span>

    <span class="c1"># print(min_vacuum_size)</span>
    <span class="c1"># sys.exit()</span>
    <span class="n">slabgen</span> <span class="o">=</span> <span class="n">SlabGenerator</span><span class="p">(</span><span class="n">pm</span><span class="p">,</span> <span class="n">miller_index</span><span class="p">,</span> <span class="n">min_slab_size</span><span class="p">,</span> <span class="n">min_vacuum_size</span><span class="p">,</span> <span class="n">in_unit_planes</span><span class="o">=</span> <span class="kc">False</span> <span class="p">,</span>  <span class="n">primitive</span> <span class="o">=</span> <span class="n">primitive</span> <span class="p">)</span>
    <span class="c1"># print(slabgen.oriented_unit_cell)</span>
    <span class="n">slabs</span> <span class="o">=</span> <span class="n">slabgen</span><span class="o">.</span><span class="n">get_slabs</span><span class="p">(</span><span class="n">symmetrize</span> <span class="o">=</span> <span class="n">symmetrize</span><span class="p">)</span>

    <span class="n">printlog</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">slabs</span><span class="p">),</span> <span class="s1">&#39;surfaces were generated, choose required surface using *surface_i* argument&#39;</span><span class="p">,</span> <span class="n">imp</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">update_from_pymatgen</span><span class="p">(</span><span class="n">slabs</span><span class="p">[</span><span class="n">surface_i</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">write_poscar</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">slab</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slabs</span><span class="p">):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">Poscar</span><span class="p">(</span><span class="n">slab</span><span class="p">)</span>
            <span class="c1"># \nWriting POSCARs to xyz</span>
            <span class="n">pos</span><span class="o">.</span><span class="n">write_file</span><span class="p">(</span><span class="s1">&#39;xyz/POSCAR_suf&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">suf</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">cut_thickness</span><span class="p">:</span>
        <span class="n">return_one</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># print(slabs[surface_i])</span>
        
        <span class="n">z</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">get_surface_pos</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># st.printme()</span>

        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">del_layers</span><span class="p">(</span><span class="n">xcart_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">z</span><span class="o">-</span><span class="n">cut_thickness</span><span class="o">+</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">z</span><span class="o">+</span><span class="mf">0.1</span><span class="p">])</span>

        <span class="c1"># print(st.rprimd[2])</span>
        <span class="n">st</span><span class="o">.</span><span class="n">rprimd</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">-=</span><span class="n">cut_thickness</span>
        <span class="c1"># print(st.rprimd[2])</span>

        <span class="n">st</span><span class="o">.</span><span class="n">update_xred</span><span class="p">()</span>

        <span class="n">st</span><span class="o">.</span><span class="n">name</span><span class="o">+=</span><span class="s1">&#39;cutted&#39;</span>
        <span class="k">if</span> <span class="n">write_poscar</span><span class="p">:</span>
            <span class="n">st</span><span class="o">.</span><span class="n">write_poscar</span><span class="p">()</span>


    <span class="k">if</span> <span class="n">return_one</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">st</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">slabs</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../../index.html">Table of Contents</a></h3>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Siman 0.9.5 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Dmitry Aksenov.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.1.
    </div>
  </body>
</html>